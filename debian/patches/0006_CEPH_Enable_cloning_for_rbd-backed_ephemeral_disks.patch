Description: Enable cloning for rbd-backed ephemeral disks
 Currently when using rbd as an image backend, nova downloads the
 glance image to local disk and then copies it again into rbd. This
 can be very slow for large images, and wastes bandwidth as well as
 disk space.
 .
 When the glance image is stored in the same ceph cluster, the data is
 being pulled out and pushed back in unnecessarily. Instead, create a
 copy-on-write clone of the image. This is fast, and does not depend
 on the size of the image. Instead of taking minutes, booting takes
 seconds, and is not limited by the disk copy.
 .
 Add some rbd utility functions from cinder to support cloning and
 let the rbd imagebackend rely on librbd instead of the rbd
 command line tool for checking image existence.
 .
 Add a direct_fetch() method to the image backend, so backends like rbd
 can make optimizations like this. Try to use direct_fetch() for the root
 disk when it comes from an image, but fall back to fetch_to_raw() if
 direct_fetch() fails.
 .
 Instead of calling disk.get_disk_size() directly from
 verify_base_size(), which assumes the disk is stored locally, add a new
 method that is overridden by the Rbd subclass to get the disk size.
From d8507cb8f6312b97d87acbca0d4b481f928b0439 Mon Sep 17 00:00:00 2001
Author: Dmitry Borodaenko <dborodaenko@mirantis.com>
Origin: upstream, https://github.com/angdraug/nova/commits/rbd-ephemeral-clone-stable-icehouse
Date: Sat, 9 Aug 2014 22:51:42 -0700
Implements: blueprint rbd-clone-image-handler
Bug-Ubuntu: https://launchpad.net/bugs/1226351
Change-Id: I9b77a50206d0eda709df8356faaeeba35d232f22
Co-Authored-By: Josh Durgin <josh.durgin@inktank.com>
Signed-off-by: Josh Durgin <josh.durgin@inktank.com>
Signed-off-by: Zhi Yan Liu <zhiyanl@cn.ibm.com>
Signed-off-by: Dmitry Borodaenko <dborodaenko@mirantis.com>
Last-Update: 2014-08-10

diff --git a/nova/tests/virt/libvirt/test_imagebackend.py b/nova/tests/virt/libvirt/test_imagebackend.py
index 9ccbbee..0eda260 100644
--- a/nova/tests/virt/libvirt/test_imagebackend.py
+++ b/nova/tests/virt/libvirt/test_imagebackend.py
@@ -397,14 +397,14 @@ def test_create_image_with_size(self):
     def test_create_image_too_small(self):
         fn = self.prepare_mocks()
         self.mox.StubOutWithMock(os.path, 'exists')
-        self.mox.StubOutWithMock(imagebackend.disk, 'get_disk_size')
+        self.mox.StubOutWithMock(imagebackend.Qcow2, 'get_disk_size')
         if self.OLD_STYLE_INSTANCE_PATH:
             os.path.exists(self.OLD_STYLE_INSTANCE_PATH).AndReturn(False)
         os.path.exists(self.DISK_INFO_PATH).AndReturn(False)
         os.path.exists(self.INSTANCES_PATH).AndReturn(True)
         os.path.exists(self.TEMPLATE_PATH).AndReturn(True)
-        imagebackend.disk.get_disk_size(self.TEMPLATE_PATH
-                                       ).AndReturn(self.SIZE)
+        imagebackend.Qcow2.get_disk_size(self.TEMPLATE_PATH
+                                         ).AndReturn(self.SIZE)
         self.mox.ReplayAll()
 
         image = self.image_class(self.INSTANCE, self.NAME)
@@ -752,6 +752,7 @@ def test_cache(self):
         self.mox.VerifyAll()
 
     def test_cache_base_dir_exists(self):
+        fn = self.mox.CreateMockAnything()
         image = self.image_class(self.INSTANCE, self.NAME)
 
         self.mox.StubOutWithMock(os.path, 'exists')
@@ -807,22 +808,72 @@ def test_create_image(self):
         fake_processutils.fake_execute_clear_log()
         fake_processutils.stub_out_processutils_execute(self.stubs)
 
-        self.mox.StubOutWithMock(imagebackend.disk, 'get_disk_size')
-        imagebackend.disk.get_disk_size(self.TEMPLATE_PATH
-                                       ).AndReturn(self.SIZE)
+        image = self.image_class(self.INSTANCE, self.NAME)
+        self.mox.StubOutWithMock(image, 'check_image_exists')
+        image.check_image_exists().AndReturn(False)
+        image.check_image_exists().AndReturn(False)
+        self.mox.ReplayAll()
+
+        image.create_image(fn, self.TEMPLATE_PATH, None)
+
         rbd_name = "%s_%s" % (self.INSTANCE['uuid'], self.NAME)
         cmd = ('rbd', 'import', '--pool', self.POOL, self.TEMPLATE_PATH,
                rbd_name, '--new-format', '--id', self.USER,
                '--conf', self.CONF)
-        self.mox.ReplayAll()
+        self.assertEqual(fake_processutils.fake_execute_get_log(),
+            [' '.join(cmd)])
+        self.mox.VerifyAll()
+
+    def test_create_image_resize(self):
+        fn = self.mox.CreateMockAnything()
+        full_size = self.SIZE * 2
+        fn(max_size=full_size, target=self.TEMPLATE_PATH)
+
+        rbd.rbd.RBD_FEATURE_LAYERING = 1
+
+        fake_processutils.fake_execute_clear_log()
+        fake_processutils.stub_out_processutils_execute(self.stubs)
 
         image = self.image_class(self.INSTANCE, self.NAME)
-        image.create_image(fn, self.TEMPLATE_PATH, None)
+        self.mox.StubOutWithMock(image, 'check_image_exists')
+        image.check_image_exists().AndReturn(False)
+        image.check_image_exists().AndReturn(False)
+        rbd_name = "%s_%s" % (self.INSTANCE['uuid'], self.NAME)
+        cmd = ('rbd', 'import', '--pool', self.POOL, self.TEMPLATE_PATH,
+               rbd_name, '--new-format', '--id', self.USER,
+               '--conf', self.CONF)
+        self.mox.StubOutWithMock(image, 'get_disk_size')
+        image.get_disk_size(rbd_name).AndReturn(self.SIZE)
+        self.mox.StubOutWithMock(image.driver, 'resize')
+        image.driver.resize(rbd_name, full_size)
+
+        self.mox.ReplayAll()
+
+        image.create_image(fn, self.TEMPLATE_PATH, full_size)
 
         self.assertEqual(fake_processutils.fake_execute_get_log(),
             [' '.join(cmd)])
         self.mox.VerifyAll()
 
+    def test_create_image_already_exists(self):
+        rbd.rbd.RBD_FEATURE_LAYERING = 1
+
+        image = self.image_class(self.INSTANCE, self.NAME)
+        self.mox.StubOutWithMock(image, 'check_image_exists')
+        image.check_image_exists().AndReturn(True)
+        self.mox.StubOutWithMock(image, 'get_disk_size')
+        image.get_disk_size(self.TEMPLATE_PATH).AndReturn(self.SIZE)
+        image.check_image_exists().AndReturn(True)
+        rbd_name = "%s_%s" % (self.INSTANCE['uuid'], self.NAME)
+        image.get_disk_size(rbd_name).AndReturn(self.SIZE)
+
+        self.mox.ReplayAll()
+
+        fn = self.mox.CreateMockAnything()
+        image.create_image(fn, self.TEMPLATE_PATH, self.SIZE)
+
+        self.mox.VerifyAll()
+
     def test_prealloc_image(self):
         CONF.set_override('preallocate_images', 'space')
 
@@ -862,6 +913,67 @@ def test_image_path(self):
 
         self.assertEqual(image.path, rbd_path)
 
+    def test_direct_fetch_success(self):
+        location = {'url': 'rbd://a/b/c/d'}
+        meta = {'disk_format': 'raw'}
+        image = self.image_class(self.INSTANCE, self.NAME)
+
+        self.mox.StubOutWithMock(image, 'check_image_exists')
+        image.check_image_exists().AndReturn(False)
+        self.mox.StubOutWithMock(image.driver, 'supports_layering')
+        image.driver.supports_layering().AndReturn(True)
+        self.mox.StubOutWithMock(image.driver, 'is_cloneable')
+        image.driver.is_cloneable(location, meta).AndReturn(True)
+        self.mox.StubOutWithMock(image.driver, 'clone')
+        image.driver.clone(location, image.rbd_name)
+        self.mox.ReplayAll()
+
+        image.direct_fetch('image_id', meta, [location])
+
+        self.mox.VerifyAll()
+
+    def test_direct_fetch_fail_no_layering(self):
+        location = {'url': 'rbd://a/b/c/d'}
+        meta = {'disk_format': 'raw'}
+        image = self.image_class(self.INSTANCE, self.NAME)
+
+        self.mox.StubOutWithMock(image, 'check_image_exists')
+        image.check_image_exists().AndReturn(False)
+        self.mox.StubOutWithMock(image.driver, 'supports_layering')
+        image.driver.supports_layering().AndReturn(False)
+        self.mox.ReplayAll()
+
+        self.assertRaises(exception.ImageUnacceptable,
+                          image.direct_fetch, 'image_id', meta, [location])
+
+    def test_direct_fetch_fail_not_raw(self):
+        location = {'url': 'rbd://a/b/c/d'}
+        meta = {}
+        image = self.image_class(self.INSTANCE, self.NAME)
+
+        self.mox.StubOutWithMock(image, 'check_image_exists')
+        image.check_image_exists().AndReturn(False)
+        self.mox.ReplayAll()
+
+        self.assertRaises(exception.ImageUnacceptable,
+                          image.direct_fetch, 'image_id', meta, [location])
+
+    def test_direct_fetch_fail_no_locations(self):
+        location = {'url': 'rbd://a/b/c/d'}
+        meta = {'disk_format': 'raw'}
+        image = self.image_class(self.INSTANCE, self.NAME)
+
+        self.mox.StubOutWithMock(image, 'check_image_exists')
+        image.check_image_exists().AndReturn(False)
+        self.mox.StubOutWithMock(image.driver, 'supports_layering')
+        image.driver.supports_layering().AndReturn(True)
+        self.mox.StubOutWithMock(image.driver, 'is_cloneable')
+        image.driver.is_cloneable(location, meta).AndReturn(False)
+        self.mox.ReplayAll()
+
+        self.assertRaises(exception.ImageUnacceptable,
+                          image.direct_fetch, 'image_id', meta, [location])
+
 
 class BackendTestCase(test.NoDBTestCase):
     INSTANCE = {'name': 'fake-instance',
diff --git a/nova/tests/virt/libvirt/test_libvirt.py b/nova/tests/virt/libvirt/test_libvirt.py
index 9ab2cc8..9314c51 100644
--- a/nova/tests/virt/libvirt/test_libvirt.py
+++ b/nova/tests/virt/libvirt/test_libvirt.py
@@ -8059,7 +8059,7 @@ def test_fetch_image(self):
         user_id = 'fake'
         project_id = 'fake'
         images.fetch_to_raw(context, image_id, target, user_id, project_id,
-                            max_size=0)
+                            max_size=0, backend=None)
 
         self.mox.ReplayAll()
         libvirt_utils.fetch_image(context, target, image_id,
diff --git a/nova/tests/virt/libvirt/test_rbd.py b/nova/tests/virt/libvirt/test_rbd.py
index 58e4039..d5e57e9 100644
--- a/nova/tests/virt/libvirt/test_rbd.py
+++ b/nova/tests/virt/libvirt/test_rbd.py
@@ -13,8 +13,8 @@
 
 import mock
 
+from nova import exception
 from nova.openstack.common import log as logging
-from nova.openstack.common import units
 from nova import test
 from nova import utils
 from nova.virt.libvirt import rbd
@@ -82,6 +82,71 @@ def setUp(self, mock_rados, mock_rbd):
     def tearDown(self):
         super(RbdTestCase, self).tearDown()
 
+    def test_good_locations(self):
+        locations = ['rbd://fsid/pool/image/snap',
+                     'rbd://%2F/%2F/%2F/%2F', ]
+        map(self.driver.parse_url, locations)
+
+    def test_bad_locations(self):
+        locations = ['rbd://image',
+                     'http://path/to/somewhere/else',
+                     'rbd://image/extra',
+                     'rbd://image/',
+                     'rbd://fsid/pool/image/',
+                     'rbd://fsid/pool/image/snap/',
+                     'rbd://///', ]
+        for loc in locations:
+            self.assertRaises(exception.ImageUnacceptable,
+                              self.driver.parse_url, loc)
+            self.assertFalse(self.driver.is_cloneable({'url': loc},
+                                                      {'disk_format': 'raw'}))
+
+    @mock.patch.object(rbd.RBDDriver, '_get_fsid')
+    @mock.patch.object(rbd, 'rbd')
+    @mock.patch.object(rbd, 'rados')
+    def test_cloneable(self, mock_rados, mock_rbd, mock_get_fsid):
+        mock_get_fsid.return_value = 'abc'
+        location = {'url': 'rbd://abc/pool/image/snap'}
+        info = {'disk_format': 'raw'}
+        self.assertTrue(self.driver.is_cloneable(location, info))
+        self.assertTrue(mock_get_fsid.called)
+
+
+    @mock.patch.object(rbd.RBDDriver, '_get_fsid')
+    def test_uncloneable_different_fsid(self, mock_get_fsid):
+        mock_get_fsid.return_value = 'abc'
+        location = {'url': 'rbd://def/pool/image/snap'}
+        self.assertFalse(
+            self.driver.is_cloneable(location, {'disk_format': 'raw'}))
+        self.assertTrue(mock_get_fsid.called)
+
+    @mock.patch.object(rbd.RBDDriver, '_get_fsid')
+    @mock.patch.object(rbd, 'RBDVolumeProxy')
+    @mock.patch.object(rbd, 'rbd')
+    @mock.patch.object(rbd, 'rados')
+    def test_uncloneable_unreadable(self, mock_rados, mock_rbd, mock_proxy,
+                                    mock_get_fsid):
+        mock_get_fsid.return_value = 'abc'
+        location = {'url': 'rbd://abc/pool/image/snap'}
+
+        mock_proxy.side_effect = self.mock_rbd.Error
+
+        self.assertFalse(
+            self.driver.is_cloneable(location, {'disk_format': 'raw'}))
+        mock_proxy.assert_called_once_with(self.driver, 'image', pool='pool',
+                                           snapshot='snap', read_only=True)
+        self.assertTrue(mock_get_fsid.called)
+
+    @mock.patch.object(rbd.RBDDriver, '_get_fsid')
+    def test_uncloneable_bad_format(self, mock_get_fsid):
+        mock_get_fsid.return_value = 'abc'
+        location = {'url': 'rbd://abc/pool/image/snap'}
+        formats = ['qcow2', 'vmdk', 'vdi']
+        for f in formats:
+            self.assertFalse(
+                self.driver.is_cloneable(location, {'disk_format': f}))
+        self.assertTrue(mock_get_fsid.called)
+
     @mock.patch.object(utils, 'execute')
     def test_get_mon_addrs(self, mock_execute):
         mock_execute.return_value = (CEPH_MON_DUMP, '')
@@ -89,6 +154,37 @@ def test_get_mon_addrs(self, mock_execute):
         ports = ['6789', '6790', '6791', '6792', '6791']
         self.assertEqual((hosts, ports), self.driver.get_mon_addrs())
 
+    @mock.patch.object(rbd, 'RADOSClient')
+    @mock.patch.object(rbd, 'rbd')
+    @mock.patch.object(rbd, 'rados')
+    def test_clone(self, mock_rados, mock_rbd, mock_client):
+        pool = u'images'
+        image = u'image-name'
+        snap = u'snapshot-name'
+        location = {'url': u'rbd://fsid/%s/%s/%s' % (pool, image, snap)}
+
+        client_stack = []
+
+        def mock__enter__(inst):
+            def _inner():
+                client_stack.append(inst)
+                return inst
+            return _inner
+
+        client = mock_client.return_value
+        # capture both rados client used to perform the clone
+        client.__enter__.side_effect = mock__enter__(client)
+
+        rbd = mock_rbd.RBD.return_value
+
+        self.driver.clone(location, self.volume_name)
+
+        args = [client_stack[0].ioctx, str(image), str(snap),
+                client_stack[1].ioctx, str(self.volume_name)]
+        kwargs = {'features': mock_rbd.RBD_FEATURE_LAYERING}
+        rbd.clone.assert_called_once_with(*args, **kwargs)
+        self.assertEqual(client.__enter__.call_count, 2)
+
     @mock.patch.object(rbd, 'RBDVolumeProxy')
     def test_resize(self, mock_proxy):
         size = 1024
@@ -164,8 +260,11 @@ def test_ceph_args_rbd_user_and_ceph_conf(self):
 
     @mock.patch.object(rbd, 'RBDVolumeProxy')
     def test_exists(self, mock_proxy):
+        snapshot = 'snap'
         proxy = mock_proxy.return_value
-        self.assertTrue(self.driver.exists(self.volume_name))
+        self.assertTrue(self.driver.exists(self.volume_name,
+                                           self.rbd_pool,
+                                           snapshot))
         proxy.__enter__.assert_called_once_with()
         proxy.__exit__.assert_called_once_with(None, None, None)
 
diff --git a/nova/tests/virt/test_images.py b/nova/tests/virt/test_images.py
index b07cb6b..df6e088 100644
--- a/nova/tests/virt/test_images.py
+++ b/nova/tests/virt/test_images.py
@@ -12,6 +12,7 @@
 #    License for the specific language governing permissions and limitations
 #    under the License.
 
+import mock
 
 from nova import test
 from nova.virt import images
@@ -22,3 +23,36 @@ def test_qemu_info_with_bad_path(self):
         image_info = images.qemu_img_info("/path/that/does/not/exist")
         self.assertTrue(image_info)
         self.assertTrue(str(image_info))
+
+
+class FetchImagesTestCase(test.NoDBTestCase):
+
+    @mock.patch('nova.image.glance.get_remote_image_service')
+    @mock.patch('nova.openstack.common.fileutils.remove_path_on_error')
+    def test_fetch(self, mock_fileutils, mock_glance):
+        mock_image_service = mock.Mock()
+        mock_glance.return_value = [mock_image_service, 'image_id']
+
+        images.fetch('context', None, 'path', None, None)
+
+        mock_image_service.download.assert_called_with(
+                'context', 'image_id', dst_path='path')
+
+    @mock.patch('nova.image.glance.get_remote_image_service')
+    def test_direct_fetch(self, mock_glance):
+        mock_image_service = mock.Mock()
+        mock_glance.return_value = [mock_image_service, 'image_id']
+        mock_image_service._get_locations.return_value = 'locations'
+        mock_image_service.show.return_value = 'image_meta'
+        mock_backend = mock.Mock()
+
+        images.direct_fetch('context', 'image_href', mock_backend)
+
+        mock_backend.direct_fetch.assert_called_with(
+                'image_id', 'image_meta', 'locations')
+
+    @mock.patch('nova.virt.images.direct_fetch')
+    def test_fetch_to_raw_direct_fetch(self, mock_direct_fetch):
+        images.fetch_to_raw('context', 'image', None, None, None,
+                            backend='backend')
+        mock_direct_fetch.assert_called_with('context', 'image', 'backend')
diff --git a/nova/virt/images.py b/nova/virt/images.py
index 6b23944..c82ccb2 100644
--- a/nova/virt/images.py
+++ b/nova/virt/images.py
@@ -72,7 +72,33 @@ def fetch(context, image_href, path, _user_id, _project_id, max_size=0):
         image_service.download(context, image_id, dst_path=path)
 
 
-def fetch_to_raw(context, image_href, path, user_id, project_id, max_size=0):
+def direct_fetch(context, image_href, backend):
+    """Allow an image backend to fetch directly from the glance backend.
+
+    :backend: the image backend, which must have a direct_fetch method
+              accepting a list of image locations. This method should raise
+              exceptions.ImageUnacceptable if the image cannot be downloaded
+              directly.
+    """
+    # TODO(jdurgin): improve auth handling as noted in fetch()
+    image_service, image_id = glance.get_remote_image_service(context,
+                                                              image_href)
+    locations = image_service._get_locations(context, image_id)
+    image_meta = image_service.show(context, image_id)
+
+    LOG.debug(_('Image locations are: %(locs)s') % {'locs': locations})
+    backend.direct_fetch(image_id, image_meta, locations)
+
+
+def fetch_to_raw(context, image_href, path, user_id, project_id, max_size=0,
+                 backend=None):
+    if backend:
+        try:
+            direct_fetch(context, image_href, backend)
+            return
+        except exception.ImageUnacceptable:
+            LOG.debug(_('could not fetch directly, falling back to download'))
+
     path_tmp = "%s.part" % path
     fetch(context, image_href, path_tmp, user_id, project_id,
           max_size=max_size)
diff --git a/nova/virt/libvirt/driver.py b/nova/virt/libvirt/driver.py
index f73a9aa..23fbfcc 100644
--- a/nova/virt/libvirt/driver.py
+++ b/nova/virt/libvirt/driver.py
@@ -2637,13 +2637,15 @@ def raw(fname):
             if size == 0 or suffix == '.rescue':
                 size = None
 
-            image('disk').cache(fetch_func=libvirt_utils.fetch_image,
-                                context=context,
-                                filename=root_fname,
-                                size=size,
-                                image_id=disk_images['image_id'],
-                                user_id=instance['user_id'],
-                                project_id=instance['project_id'])
+            backend = image('disk')
+            backend.cache(fetch_func=libvirt_utils.fetch_image,
+                          context=context,
+                          filename=root_fname,
+                          size=size,
+                          backend=backend,
+                          image_id=disk_images['image_id'],
+                          user_id=instance['user_id'],
+                          project_id=instance['project_id'])
 
         # Lookup the filesystem type if required
         os_type_with_default = disk.get_fs_type_for_os_type(
diff --git a/nova/virt/libvirt/imagebackend.py b/nova/virt/libvirt/imagebackend.py
index 5bff9d7..5f15e30 100644
--- a/nova/virt/libvirt/imagebackend.py
+++ b/nova/virt/libvirt/imagebackend.py
@@ -206,8 +206,7 @@ def _can_fallocate(self):
                                            'path': self.path})
         return can_fallocate
 
-    @staticmethod
-    def verify_base_size(base, size, base_size=0):
+    def verify_base_size(self, base, size, base_size=0):
         """Check that the base image is not larger than size.
            Since images can't be generally shrunk, enforce this
            constraint taking account of virtual image size.
@@ -226,7 +225,7 @@ def verify_base_size(base, size, base_size=0):
             return
 
         if size and not base_size:
-            base_size = disk.get_disk_size(base)
+            base_size = self.get_disk_size(base)
 
         if size < base_size:
             msg = _('%(base)s virtual size %(base_size)s '
@@ -236,6 +235,9 @@ def verify_base_size(base, size, base_size=0):
                               'size': size})
             raise exception.FlavorDiskTooSmall()
 
+    def get_disk_size(self, name):
+        disk.get_disk_size(name)
+
     def snapshot_extract(self, target, out_format):
         raise NotImplementedError()
 
@@ -304,6 +306,14 @@ def is_shared_block_storage():
         '''
         return False
 
+    def direct_fetch(self, image_id, image_meta, image_locations):
+        """Create an image from a direct image location.
+
+        :raises: exception.ImageUnacceptable if it cannot be fetched directly
+        """
+        reason = _('direct_fetch() is not implemented')
+        raise exception.ImageUnacceptable(image_id=image_id, reason=reason)
+
 
 class Raw(Image):
     def __init__(self, instance=None, disk_name=None, path=None):
@@ -534,7 +544,7 @@ def libvirt_info(self, disk_bus, disk_dev, device_type, cache_mode,
         info = vconfig.LibvirtConfigGuestDisk()
 
         hosts, ports = self.driver.get_mon_addrs()
-        info.device_type = device_type
+        info.source_device = device_type
         info.driver_format = 'raw'
         info.driver_cache = cache_mode
         info.target_bus = disk_bus
@@ -559,23 +569,29 @@ def _can_fallocate(self):
         return False
 
     def check_image_exists(self):
-        rbd_volumes = libvirt_utils.list_rbd_volumes(self.pool)
-        for vol in rbd_volumes:
-            if vol.startswith(self.rbd_name):
-                return True
+        return self.driver.exists(self.rbd_name)
 
-        return False
+    def get_disk_size(self, name):
+        """Returns the size of the virtual disk in bytes.
+
+        The name argument is ignored since this backend already knows
+        its name, and callers may pass a non-existent local file path.
+        """
+        return self.driver.size(self.rbd_name)
 
     def create_image(self, prepare_template, base, size, *args, **kwargs):
-        if not os.path.exists(base):
+
+        if not self.check_image_exists():
             prepare_template(target=base, max_size=size, *args, **kwargs)
         else:
             self.verify_base_size(base, size)
 
-        self.driver.import_image(base, self.rbd_name)
+        # prepare_template() may have cloned the image into a new rbd
+        # image already instead of downloading it locally
+        if not self.check_image_exists():
+            self.driver.import_image(base, self.rbd_name)
 
-        base_size = disk.get_disk_size(base)
-        if size and size > base_size:
+        if size and size > self.get_disk_size(self.rbd_name):
             self.driver.resize(self.rbd_name, size)
 
     def snapshot_extract(self, target, out_format):
@@ -585,6 +601,23 @@ def snapshot_extract(self, target, out_format):
     def is_shared_block_storage():
         return True
 
+    def direct_fetch(self, image_id, image_meta, image_locations):
+        if self.check_image_exists():
+            return
+        if image_meta.get('disk_format') not in ['raw', 'iso']:
+            reason = _('Image is not raw format')
+            raise exception.ImageUnacceptable(image_id=image_id, reason=reason)
+        if not self.driver.supports_layering():
+            reason = _('installed version of librbd does not support cloning')
+            raise exception.ImageUnacceptable(image_id=image_id, reason=reason)
+
+        for location in image_locations:
+            if self.driver.is_cloneable(location, image_meta):
+                return self.driver.clone(location, self.rbd_name)
+
+        reason = _('No image locations are accessible')
+        raise exception.ImageUnacceptable(image_id=image_id, reason=reason)
+
 
 class Backend(object):
     def __init__(self, use_cow):
diff --git a/nova/virt/libvirt/rbd.py b/nova/virt/libvirt/rbd.py
index f06a362..4658199 100644
--- a/nova/virt/libvirt/rbd.py
+++ b/nova/virt/libvirt/rbd.py
@@ -14,6 +14,8 @@
 #    License for the specific language governing permissions and limitations
 #    under the License.
 
+import urllib
+
 try:
     import rados
     import rbd
@@ -21,6 +23,8 @@
     rados = None
     rbd = None
 
+from nova import exception
+from nova.openstack.common import excutils
 from nova.openstack.common.gettextutils import _
 from nova.openstack.common import jsonutils
 from nova.openstack.common import log as logging
@@ -38,14 +42,23 @@ class RBDVolumeProxy(object):
     The underlying librados client and ioctx can be accessed as the attributes
     'client' and 'ioctx'.
     """
-    def __init__(self, driver, name, pool=None):
+    def __init__(self, driver, name, pool=None, snapshot=None,
+                 read_only=False):
         client, ioctx = driver._connect_to_rados(pool)
         try:
-            self.volume = rbd.Image(ioctx, str(name), snapshot=None)
+            snap_name = snapshot.encode('utf8') if snapshot else None
+            self.volume = rbd.Image(ioctx, name.encode('utf8'),
+                                    snapshot=snap_name,
+                                    read_only=read_only)
+        except rbd.ImageNotFound:
+            with excutils.save_and_reraise_exception():
+                LOG.debug("rbd image %s does not exist", name)
+                driver._disconnect_from_rados(client, ioctx)
         except rbd.Error:
-            LOG.exception(_("error opening rbd image %s"), name)
-            driver._disconnect_from_rados(client, ioctx)
-            raise
+            with excutils.save_and_reraise_exception():
+                LOG.exception(_("error opening rbd image %s"), name)
+                driver._disconnect_from_rados(client, ioctx)
+
         self.driver = driver
         self.client = client
         self.ioctx = ioctx
@@ -92,8 +105,8 @@ def _connect_to_rados(self, pool=None):
                              conffile=self.ceph_conf)
         try:
             client.connect()
-            pool_to_open = str(pool or self.pool)
-            ioctx = client.open_ioctx(pool_to_open)
+            pool_to_open = pool or self.pool
+            ioctx = client.open_ioctx(pool_to_open.encode('utf-8'))
             return client, ioctx
         except rados.Error:
             # shutdown cannot raise an exception
@@ -137,6 +150,66 @@ def get_mon_addrs(self):
             ports.append(port)
         return hosts, ports
 
+    def parse_url(self, url):
+        prefix = 'rbd://'
+        if not url.startswith(prefix):
+            reason = _('Not stored in rbd')
+            raise exception.ImageUnacceptable(image_id=url, reason=reason)
+        pieces = map(urllib.unquote, url[len(prefix):].split('/'))
+        if '' in pieces:
+            reason = _('Blank components')
+            raise exception.ImageUnacceptable(image_id=url, reason=reason)
+        if len(pieces) != 4:
+            reason = _('Not an rbd snapshot')
+            raise exception.ImageUnacceptable(image_id=url, reason=reason)
+        return pieces
+
+    def _get_fsid(self):
+        with RADOSClient(self) as client:
+            return client.cluster.get_fsid()
+
+    def is_cloneable(self, image_location, image_meta):
+        url = image_location['url']
+        try:
+            fsid, pool, image, snapshot = self.parse_url(url)
+        except exception.ImageUnacceptable as e:
+            LOG.debug(_('not cloneable: %s'), e)
+            return False
+
+        if self._get_fsid() != fsid:
+            reason = _('%s is in a different ceph cluster') % url
+            LOG.debug(reason)
+            return False
+
+        if image_meta['disk_format'] != 'raw':
+            reason = _("rbd image clone requires image format to be "
+                       "'raw' but image {0} is '{1}'").format(
+                           url, image_meta['disk_format'])
+            LOG.debug(reason)
+            return False
+
+        # check that we can read the image
+        try:
+            return self.exists(image, pool=pool, snapshot=snapshot)
+        except rbd.Error as e:
+            LOG.debug(_('Unable to open image %(loc)s: %(err)s') %
+                      dict(loc=url, err=e))
+            return False
+
+    def clone(self, image_location, dest_name):
+        _fsid, pool, image, snapshot = self.parse_url(
+                image_location['url'])
+        LOG.debug(_('cloning %(pool)s/%(img)s@%(snap)s') %
+                  dict(pool=pool, img=image, snap=snapshot))
+        with RADOSClient(self, str(pool)) as src_client:
+            with RADOSClient(self) as dest_client:
+                rbd.RBD().clone(src_client.ioctx,
+                                     image.encode('utf-8'),
+                                     snapshot.encode('utf-8'),
+                                     dest_client.ioctx,
+                                     dest_name,
+                                     features=rbd.RBD_FEATURE_LAYERING)
+
     def size(self, name):
         with RBDVolumeProxy(self, name) as vol:
             return vol.size()
@@ -151,9 +224,12 @@ def resize(self, name, size):
         with RBDVolumeProxy(self, name) as vol:
             vol.resize(size)
 
-    def exists(self, name):
+    def exists(self, name, pool=None, snapshot=None):
         try:
-            with RBDVolumeProxy(self, name):
+            with RBDVolumeProxy(self, name,
+                                pool=pool,
+                                snapshot=snapshot,
+                                read_only=True):
                 return True
         except rbd.ImageNotFound:
             return False
diff --git a/nova/virt/libvirt/utils.py b/nova/virt/libvirt/utils.py
index 21b02f6..53dd411 100644
--- a/nova/virt/libvirt/utils.py
+++ b/nova/virt/libvirt/utils.py
@@ -607,10 +607,11 @@ def get_fs_info(path):
             'used': used}
 
 
-def fetch_image(context, target, image_id, user_id, project_id, max_size=0):
+def fetch_image(context, target, image_id, user_id, project_id, max_size=0,
+                backend=None):
     """Grab image."""
     images.fetch_to_raw(context, image_id, target, user_id, project_id,
-                        max_size=max_size)
+                        max_size=max_size, backend=backend)
 
 
 def get_instance_path(instance, forceold=False, relative=False):
-- 
2.0.3

