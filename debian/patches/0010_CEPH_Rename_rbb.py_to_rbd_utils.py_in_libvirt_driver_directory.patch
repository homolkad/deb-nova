Description: Rename rbd.py to rbd_utils.py in libvirt driver directory
 In libvirt driver directory, rbd.py confict with global rbd library which is
 imported in rbd.py, so we rename rbd.py to rbd_utils.py.
Author: Yaguang Tang <yaguang.tang@canonical.com>
Date: Tue, 5 Aug 2014 11:06:10 +0800
Origin: https://github.com/angdraug/nova/commit/e2587bd49485783bfa86a358316d9776ec0c903e
Last-Update: 2014-08-22

diff --git a/nova/tests/virt/libvirt/test_imagebackend.py b/nova/tests/virt/libvirt/test_imagebackend.py
index 0eda260..3153e75 100644
--- a/nova/tests/virt/libvirt/test_imagebackend.py
+++ b/nova/tests/virt/libvirt/test_imagebackend.py
@@ -30,7 +30,7 @@ from nova.tests import fake_processutils
 from nova.tests.virt.libvirt import fake_libvirt_utils
 from nova import utils
 from nova.virt.libvirt import imagebackend
-from nova.virt.libvirt import rbd
+from nova.virt.libvirt import rbd_utils
 
 CONF = cfg.CONF
 
@@ -730,8 +730,8 @@ class RbdTestCase(_ImageTestCase, test.NoDBTestCase):
                    group='libvirt')
         self.libvirt_utils = imagebackend.libvirt_utils
         self.utils = imagebackend.utils
-        self.mox.StubOutWithMock(rbd, 'rbd')
-        self.mox.StubOutWithMock(rbd, 'rados')
+        self.mox.StubOutWithMock(rbd_utils, 'rbd')
+        self.mox.StubOutWithMock(rbd_utils, 'rados')
 
     def test_cache(self):
         image = self.image_class(self.INSTANCE, self.NAME)
@@ -803,7 +803,7 @@ class RbdTestCase(_ImageTestCase, test.NoDBTestCase):
         fn = self.mox.CreateMockAnything()
         fn(max_size=None, target=self.TEMPLATE_PATH)
 
-        rbd.rbd.RBD_FEATURE_LAYERING = 1
+        rbd_utils.rbd.RBD_FEATURE_LAYERING = 1
 
         fake_processutils.fake_execute_clear_log()
         fake_processutils.stub_out_processutils_execute(self.stubs)
@@ -829,7 +829,7 @@ class RbdTestCase(_ImageTestCase, test.NoDBTestCase):
         full_size = self.SIZE * 2
         fn(max_size=full_size, target=self.TEMPLATE_PATH)
 
-        rbd.rbd.RBD_FEATURE_LAYERING = 1
+        rbd_utils.rbd.RBD_FEATURE_LAYERING = 1
 
         fake_processutils.fake_execute_clear_log()
         fake_processutils.stub_out_processutils_execute(self.stubs)
@@ -856,7 +856,7 @@ class RbdTestCase(_ImageTestCase, test.NoDBTestCase):
         self.mox.VerifyAll()
 
     def test_create_image_already_exists(self):
-        rbd.rbd.RBD_FEATURE_LAYERING = 1
+        rbd_utils.rbd.RBD_FEATURE_LAYERING = 1
 
         image = self.image_class(self.INSTANCE, self.NAME)
         self.mox.StubOutWithMock(image, 'check_image_exists')
@@ -1020,8 +1020,8 @@ class BackendTestCase(test.NoDBTestCase):
         pool = "FakePool"
         self.flags(images_rbd_pool=pool, group='libvirt')
         self.flags(images_rbd_ceph_conf=conf, group='libvirt')
-        self.mox.StubOutWithMock(rbd, 'rbd')
-        self.mox.StubOutWithMock(rbd, 'rados')
+        self.mox.StubOutWithMock(rbd_utils, 'rbd')
+        self.mox.StubOutWithMock(rbd_utils, 'rados')
         self._test_image('rbd', imagebackend.Rbd, imagebackend.Rbd)
 
     def test_image_default(self):
diff --git a/nova/tests/virt/libvirt/test_libvirt.py b/nova/tests/virt/libvirt/test_libvirt.py
index e3dac62..93e0116 100644
--- a/nova/tests/virt/libvirt/test_libvirt.py
+++ b/nova/tests/virt/libvirt/test_libvirt.py
@@ -77,7 +77,7 @@ from nova.virt.libvirt import config as vconfig
 from nova.virt.libvirt import driver as libvirt_driver
 from nova.virt.libvirt import firewall
 from nova.virt.libvirt import imagebackend
-from nova.virt.libvirt import rbd
+from nova.virt.libvirt import rbd_utils
 from nova.virt.libvirt import utils as libvirt_utils
 from nova.virt import netutils
 
@@ -5673,7 +5673,7 @@ class LibvirtConnTestCase(test.TestCase):
                     "uuid": "875a8070-d0b9-4949-8b31-104d125c9a64"}
         conn.destroy(self.context, instance, [])
 
-    @mock.patch.object(rbd, 'RBDDriver')
+    @mock.patch.object(rbd_utils, 'RBDDriver')
     def test_cleanup_rbd(self, mock_driver):
         driver = mock_driver.return_value
         driver.cleanup_volumes = mock.Mock()
diff --git a/nova/tests/virt/libvirt/test_rbd.py b/nova/tests/virt/libvirt/test_rbd.py
index d5e57e9..1a18838 100644
--- a/nova/tests/virt/libvirt/test_rbd.py
+++ b/nova/tests/virt/libvirt/test_rbd.py
@@ -17,7 +17,7 @@ from nova import exception
 from nova.openstack.common import log as logging
 from nova import test
 from nova import utils
-from nova.virt.libvirt import rbd
+from nova.virt.libvirt import rbd_utils
 
 
 LOG = logging.getLogger(__name__)
@@ -53,8 +53,8 @@ CEPH_MON_DUMP = """dumped monmap epoch 1
 
 class RbdTestCase(test.NoDBTestCase):
 
-    @mock.patch.object(rbd, 'rbd')
-    @mock.patch.object(rbd, 'rados')
+    @mock.patch.object(rbd_utils, 'rbd')
+    @mock.patch.object(rbd_utils, 'rados')
     def setUp(self, mock_rados, mock_rbd):
         super(RbdTestCase, self).setUp()
 
@@ -75,7 +75,7 @@ class RbdTestCase(test.NoDBTestCase):
         self.mock_rbd.RBD.Error = Exception
 
         self.rbd_pool = 'rbd'
-        self.driver = rbd.RBDDriver(self.rbd_pool, None, None)
+        self.driver = rbd_utils.RBDDriver(self.rbd_pool, None, None)
 
         self.volume_name = u'volume-00000001'
 
@@ -101,9 +101,9 @@ class RbdTestCase(test.NoDBTestCase):
             self.assertFalse(self.driver.is_cloneable({'url': loc},
                                                       {'disk_format': 'raw'}))
 
-    @mock.patch.object(rbd.RBDDriver, '_get_fsid')
-    @mock.patch.object(rbd, 'rbd')
-    @mock.patch.object(rbd, 'rados')
+    @mock.patch.object(rbd_utils.RBDDriver, '_get_fsid')
+    @mock.patch.object(rbd_utils, 'rbd')
+    @mock.patch.object(rbd_utils, 'rados')
     def test_cloneable(self, mock_rados, mock_rbd, mock_get_fsid):
         mock_get_fsid.return_value = 'abc'
         location = {'url': 'rbd://abc/pool/image/snap'}
@@ -111,8 +111,7 @@ class RbdTestCase(test.NoDBTestCase):
         self.assertTrue(self.driver.is_cloneable(location, info))
         self.assertTrue(mock_get_fsid.called)
 
-
-    @mock.patch.object(rbd.RBDDriver, '_get_fsid')
+    @mock.patch.object(rbd_utils.RBDDriver, '_get_fsid')
     def test_uncloneable_different_fsid(self, mock_get_fsid):
         mock_get_fsid.return_value = 'abc'
         location = {'url': 'rbd://def/pool/image/snap'}
@@ -120,10 +119,10 @@ class RbdTestCase(test.NoDBTestCase):
             self.driver.is_cloneable(location, {'disk_format': 'raw'}))
         self.assertTrue(mock_get_fsid.called)
 
-    @mock.patch.object(rbd.RBDDriver, '_get_fsid')
-    @mock.patch.object(rbd, 'RBDVolumeProxy')
-    @mock.patch.object(rbd, 'rbd')
-    @mock.patch.object(rbd, 'rados')
+    @mock.patch.object(rbd_utils.RBDDriver, '_get_fsid')
+    @mock.patch.object(rbd_utils, 'RBDVolumeProxy')
+    @mock.patch.object(rbd_utils, 'rbd')
+    @mock.patch.object(rbd_utils, 'rados')
     def test_uncloneable_unreadable(self, mock_rados, mock_rbd, mock_proxy,
                                     mock_get_fsid):
         mock_get_fsid.return_value = 'abc'
@@ -137,7 +136,7 @@ class RbdTestCase(test.NoDBTestCase):
                                            snapshot='snap', read_only=True)
         self.assertTrue(mock_get_fsid.called)
 
-    @mock.patch.object(rbd.RBDDriver, '_get_fsid')
+    @mock.patch.object(rbd_utils.RBDDriver, '_get_fsid')
     def test_uncloneable_bad_format(self, mock_get_fsid):
         mock_get_fsid.return_value = 'abc'
         location = {'url': 'rbd://abc/pool/image/snap'}
@@ -154,9 +153,9 @@ class RbdTestCase(test.NoDBTestCase):
         ports = ['6789', '6790', '6791', '6792', '6791']
         self.assertEqual((hosts, ports), self.driver.get_mon_addrs())
 
-    @mock.patch.object(rbd, 'RADOSClient')
-    @mock.patch.object(rbd, 'rbd')
-    @mock.patch.object(rbd, 'rados')
+    @mock.patch.object(rbd_utils, 'RADOSClient')
+    @mock.patch.object(rbd_utils, 'rbd')
+    @mock.patch.object(rbd_utils, 'rados')
     def test_clone(self, mock_rados, mock_rbd, mock_client):
         pool = u'images'
         image = u'image-name'
@@ -185,7 +184,7 @@ class RbdTestCase(test.NoDBTestCase):
         rbd.clone.assert_called_once_with(*args, **kwargs)
         self.assertEqual(client.__enter__.call_count, 2)
 
-    @mock.patch.object(rbd, 'RBDVolumeProxy')
+    @mock.patch.object(rbd_utils, 'RBDVolumeProxy')
     def test_resize(self, mock_proxy):
         size = 1024
         proxy = mock_proxy.return_value
@@ -193,24 +192,24 @@ class RbdTestCase(test.NoDBTestCase):
         self.driver.resize(self.volume_name, size)
         proxy.resize.assert_called_once_with(size)
 
-    @mock.patch.object(rbd.RBDDriver, '_disconnect_from_rados')
-    @mock.patch.object(rbd.RBDDriver, '_connect_to_rados')
-    @mock.patch.object(rbd, 'rbd')
-    @mock.patch.object(rbd, 'rados')
+    @mock.patch.object(rbd_utils.RBDDriver, '_disconnect_from_rados')
+    @mock.patch.object(rbd_utils.RBDDriver, '_connect_to_rados')
+    @mock.patch.object(rbd_utils, 'rbd')
+    @mock.patch.object(rbd_utils, 'rados')
     def test_rbd_volume_proxy_init(self, mock_rados, mock_rbd,
                                    mock_connect_from_rados,
                                    mock_disconnect_from_rados):
         mock_connect_from_rados.return_value = (None, None)
         mock_disconnect_from_rados.return_value = (None, None)
 
-        with rbd.RBDVolumeProxy(self.driver, self.volume_name):
+        with rbd_utils.RBDVolumeProxy(self.driver, self.volume_name):
             mock_connect_from_rados.assert_called_once_with(None)
             self.assertFalse(mock_disconnect_from_rados.called)
 
         mock_disconnect_from_rados.assert_called_once_with(None, None)
 
-    @mock.patch.object(rbd, 'rbd')
-    @mock.patch.object(rbd, 'rados')
+    @mock.patch.object(rbd_utils, 'rbd')
+    @mock.patch.object(rbd_utils, 'rados')
     def test_connect_to_rados_default(self, mock_rados, mock_rbd):
         ret = self.driver._connect_to_rados()
         self.assertTrue(self.mock_rados.Rados.connect.called)
@@ -219,8 +218,8 @@ class RbdTestCase(test.NoDBTestCase):
         self.assertEqual(ret[1], self.mock_rados.Rados.ioctx)
         self.mock_rados.Rados.open_ioctx.assert_called_with(self.rbd_pool)
 
-    @mock.patch.object(rbd, 'rbd')
-    @mock.patch.object(rbd, 'rados')
+    @mock.patch.object(rbd_utils, 'rbd')
+    @mock.patch.object(rbd_utils, 'rados')
     def test_connect_to_rados_different_pool(self, mock_rados, mock_rbd):
         ret = self.driver._connect_to_rados('alt_pool')
         self.assertTrue(self.mock_rados.Rados.connect.called)
@@ -229,7 +228,7 @@ class RbdTestCase(test.NoDBTestCase):
         self.assertEqual(ret[1], self.mock_rados.Rados.ioctx)
         self.mock_rados.Rados.open_ioctx.assert_called_with('alt_pool')
 
-    @mock.patch.object(rbd, 'rados')
+    @mock.patch.object(rbd_utils, 'rados')
     def test_connect_to_rados_error(self, mock_rados):
         self.mock_rados.Rados.open_ioctx.side_effect = mock_rados.Error
         self.assertRaises(mock_rados.Error, self.driver._connect_to_rados)
@@ -258,7 +257,7 @@ class RbdTestCase(test.NoDBTestCase):
         self.assertEqual(['--id', 'foo', '--conf', '/path/bar.conf'],
                          self.driver.ceph_args())
 
-    @mock.patch.object(rbd, 'RBDVolumeProxy')
+    @mock.patch.object(rbd_utils, 'RBDVolumeProxy')
     def test_exists(self, mock_proxy):
         snapshot = 'snap'
         proxy = mock_proxy.return_value
@@ -268,9 +267,9 @@ class RbdTestCase(test.NoDBTestCase):
         proxy.__enter__.assert_called_once_with()
         proxy.__exit__.assert_called_once_with(None, None, None)
 
-    @mock.patch.object(rbd, 'rbd')
-    @mock.patch.object(rbd, 'rados')
-    @mock.patch.object(rbd, 'RADOSClient')
+    @mock.patch.object(rbd_utils, 'rbd')
+    @mock.patch.object(rbd_utils, 'rados')
+    @mock.patch.object(rbd_utils, 'RADOSClient')
     def test_cleanup_volumes(self, mock_client, mock_rados, mock_rbd):
         instance = {'uuid': '12345'}
 
diff --git a/nova/virt/libvirt/driver.py b/nova/virt/libvirt/driver.py
index c799eb5..8c7ba7a 100644
--- a/nova/virt/libvirt/driver.py
+++ b/nova/virt/libvirt/driver.py
@@ -102,7 +102,7 @@ from nova.virt.libvirt import config as vconfig
 from nova.virt.libvirt import firewall as libvirt_firewall
 from nova.virt.libvirt import imagebackend
 from nova.virt.libvirt import imagecache
-from nova.virt.libvirt import rbd
+from nova.virt.libvirt import rbd_utils
 from nova.virt.libvirt import utils as libvirt_utils
 from nova.virt import netutils
 from nova.virt import watchdog_actions
@@ -1082,7 +1082,7 @@ class LibvirtDriver(driver.ComputeDriver):
 
     @staticmethod
     def _get_rbd_driver():
-        return rbd.RBDDriver(
+        return rbd_utils.RBDDriver(
                 pool=CONF.libvirt.images_rbd_pool,
                 ceph_conf=CONF.libvirt.images_rbd_ceph_conf,
                 rbd_user=CONF.libvirt.rbd_user)
diff --git a/nova/virt/libvirt/imagebackend.py b/nova/virt/libvirt/imagebackend.py
index 48fca39..a7eb324 100644
--- a/nova/virt/libvirt/imagebackend.py
+++ b/nova/virt/libvirt/imagebackend.py
@@ -32,7 +32,7 @@ from nova import utils
 from nova.virt.disk import api as disk
 from nova.virt import images
 from nova.virt.libvirt import config as vconfig
-from nova.virt.libvirt import rbd
+from nova.virt.libvirt import rbd_utils
 from nova.virt.libvirt import utils as libvirt_utils
 
 __imagebackend_opts = [
@@ -533,7 +533,7 @@ class Rbd(Image):
         self.rbd_user = CONF.libvirt.rbd_user
         self.ceph_conf = CONF.libvirt.images_rbd_ceph_conf
 
-        self.driver = rbd.RBDDriver(
+        self.driver = rbd_utils.RBDDriver(
             pool=self.pool,
             ceph_conf=self.ceph_conf,
             rbd_user=self.rbd_user)
diff --git a/nova/virt/libvirt/rbd.py b/nova/virt/libvirt/rbd.py
deleted file mode 100644
index fce4b3d..0000000
--- a/nova/virt/libvirt/rbd.py
+++ /dev/null
@@ -1,274 +0,0 @@
-# Copyright 2012 Grid Dynamics
-# Copyright 2013 Inktank Storage, Inc.
-# Copyright 2014 Mirantis, Inc.
-#
-#    Licensed under the Apache License, Version 2.0 (the "License"); you may
-#    not use this file except in compliance with the License. You may obtain
-#    a copy of the License at
-#
-#         http://www.apache.org/licenses/LICENSE-2.0
-#
-#    Unless required by applicable law or agreed to in writing, software
-#    distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
-#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
-#    License for the specific language governing permissions and limitations
-#    under the License.
-
-import urllib
-
-try:
-    import rados
-    import rbd
-except ImportError:
-    rados = None
-    rbd = None
-
-from nova import exception
-from nova.openstack.common import excutils
-from nova.openstack.common.gettextutils import _
-from nova.openstack.common import jsonutils
-from nova.openstack.common import log as logging
-from nova.openstack.common import units
-from nova import utils
-
-LOG = logging.getLogger(__name__)
-
-
-class RBDVolumeProxy(object):
-    """Context manager for dealing with an existing rbd volume.
-
-    This handles connecting to rados and opening an ioctx automatically, and
-    otherwise acts like a librbd Image object.
-
-    The underlying librados client and ioctx can be accessed as the attributes
-    'client' and 'ioctx'.
-    """
-    def __init__(self, driver, name, pool=None, snapshot=None,
-                 read_only=False):
-        client, ioctx = driver._connect_to_rados(pool)
-        try:
-            snap_name = snapshot.encode('utf8') if snapshot else None
-            self.volume = rbd.Image(ioctx, name.encode('utf8'),
-                                    snapshot=snap_name,
-                                    read_only=read_only)
-        except rbd.ImageNotFound:
-            with excutils.save_and_reraise_exception():
-                LOG.debug("rbd image %s does not exist", name)
-                driver._disconnect_from_rados(client, ioctx)
-        except rbd.Error:
-            with excutils.save_and_reraise_exception():
-                LOG.exception(_("error opening rbd image %s"), name)
-                driver._disconnect_from_rados(client, ioctx)
-
-        self.driver = driver
-        self.client = client
-        self.ioctx = ioctx
-
-    def __enter__(self):
-        return self
-
-    def __exit__(self, type_, value, traceback):
-        try:
-            self.volume.close()
-        finally:
-            self.driver._disconnect_from_rados(self.client, self.ioctx)
-
-    def __getattr__(self, attrib):
-        return getattr(self.volume, attrib)
-
-
-class RADOSClient(object):
-    """Context manager to simplify error handling for connecting to ceph."""
-    def __init__(self, driver, pool=None):
-        self.driver = driver
-        self.cluster, self.ioctx = driver._connect_to_rados(pool)
-
-    def __enter__(self):
-        return self
-
-    def __exit__(self, type_, value, traceback):
-        self.driver._disconnect_from_rados(self.cluster, self.ioctx)
-
-
-class RBDDriver(object):
-
-    def __init__(self, pool, ceph_conf, rbd_user):
-        self.pool = pool.encode('utf8')
-        # NOTE(angdraug): rados.Rados fails to connect if ceph_conf is None:
-        # https://github.com/ceph/ceph/pull/1787
-        self.ceph_conf = ceph_conf.encode('utf8') if ceph_conf else ''
-        self.rbd_user = rbd_user.encode('utf8') if rbd_user else None
-        if rbd is None:
-            raise RuntimeError(_('rbd python libraries not found'))
-
-    def _connect_to_rados(self, pool=None):
-        client = rados.Rados(rados_id=self.rbd_user,
-                             conffile=self.ceph_conf)
-        try:
-            client.connect()
-            pool_to_open = pool or self.pool
-            ioctx = client.open_ioctx(pool_to_open.encode('utf-8'))
-            return client, ioctx
-        except rados.Error:
-            # shutdown cannot raise an exception
-            client.shutdown()
-            raise
-
-    def _disconnect_from_rados(self, client, ioctx):
-        # closing an ioctx cannot raise an exception
-        ioctx.close()
-        client.shutdown()
-
-    def supports_layering(self):
-        return hasattr(rbd, 'RBD_FEATURE_LAYERING')
-
-    def ceph_args(self):
-        """List of command line parameters to be passed to ceph commands to
-           reflect RBDDriver configuration such as RBD user name and location
-           of ceph.conf.
-        """
-        args = []
-        if self.rbd_user:
-            args.extend(['--id', self.rbd_user])
-        if self.ceph_conf:
-            args.extend(['--conf', self.ceph_conf])
-        return args
-
-    def get_mon_addrs(self):
-        args = ['ceph', 'mon', 'dump', '--format=json'] + self.ceph_args()
-        out, _ = utils.execute(*args)
-        lines = out.split('\n')
-        if lines[0].startswith('dumped monmap epoch'):
-            lines = lines[1:]
-        monmap = jsonutils.loads('\n'.join(lines))
-        addrs = [mon['addr'] for mon in monmap['mons']]
-        hosts = []
-        ports = []
-        for addr in addrs:
-            host_port = addr[:addr.rindex('/')]
-            host, port = host_port.rsplit(':', 1)
-            hosts.append(host.strip('[]'))
-            ports.append(port)
-        return hosts, ports
-
-    def parse_url(self, url):
-        prefix = 'rbd://'
-        if not url.startswith(prefix):
-            reason = _('Not stored in rbd')
-            raise exception.ImageUnacceptable(image_id=url, reason=reason)
-        pieces = map(urllib.unquote, url[len(prefix):].split('/'))
-        if '' in pieces:
-            reason = _('Blank components')
-            raise exception.ImageUnacceptable(image_id=url, reason=reason)
-        if len(pieces) != 4:
-            reason = _('Not an rbd snapshot')
-            raise exception.ImageUnacceptable(image_id=url, reason=reason)
-        return pieces
-
-    def _get_fsid(self):
-        with RADOSClient(self) as client:
-            return client.cluster.get_fsid()
-
-    def is_cloneable(self, image_location, image_meta):
-        url = image_location['url']
-        try:
-            fsid, pool, image, snapshot = self.parse_url(url)
-        except exception.ImageUnacceptable as e:
-            LOG.debug(_('not cloneable: %s'), e)
-            return False
-
-        if self._get_fsid() != fsid:
-            reason = _('%s is in a different ceph cluster') % url
-            LOG.debug(reason)
-            return False
-
-        if image_meta['disk_format'] != 'raw':
-            reason = _("rbd image clone requires image format to be "
-                       "'raw' but image {0} is '{1}'").format(
-                           url, image_meta['disk_format'])
-            LOG.debug(reason)
-            return False
-
-        # check that we can read the image
-        try:
-            return self.exists(image, pool=pool, snapshot=snapshot)
-        except rbd.Error as e:
-            LOG.debug(_('Unable to open image %(loc)s: %(err)s') %
-                      dict(loc=url, err=e))
-            return False
-
-    def clone(self, image_location, dest_name):
-        _fsid, pool, image, snapshot = self.parse_url(
-                image_location['url'])
-        LOG.debug(_('cloning %(pool)s/%(img)s@%(snap)s') %
-                  dict(pool=pool, img=image, snap=snapshot))
-        with RADOSClient(self, str(pool)) as src_client:
-            with RADOSClient(self) as dest_client:
-                rbd.RBD().clone(src_client.ioctx,
-                                     image.encode('utf-8'),
-                                     snapshot.encode('utf-8'),
-                                     dest_client.ioctx,
-                                     dest_name,
-                                     features=rbd.RBD_FEATURE_LAYERING)
-
-    def size(self, name):
-        with RBDVolumeProxy(self, name) as vol:
-            return vol.size()
-
-    def resize(self, name, size):
-        """Resize RBD volume.
-
-        :name: Name of RBD object
-        :size: New size in bytes
-        """
-        LOG.debug('resizing rbd image %s to %d', name, size)
-        with RBDVolumeProxy(self, name) as vol:
-            vol.resize(size)
-
-    def exists(self, name, pool=None, snapshot=None):
-        try:
-            with RBDVolumeProxy(self, name,
-                                pool=pool,
-                                snapshot=snapshot,
-                                read_only=True):
-                return True
-        except rbd.ImageNotFound:
-            return False
-
-    def import_image(self, base, name):
-        """Import RBD volume from image file.
-
-        Uses the command line import instead of librbd since rbd import
-        command detects zeroes to preserve sparseness in the image.
-
-        :base: Path to image file
-        :name: Name of RBD volume
-        """
-        args = ['--pool', self.pool, base, name]
-        if self.supports_layering():
-            args += ['--new-format']
-        args += self.ceph_args()
-        utils.execute('rbd', 'import', *args)
-
-    def cleanup_volumes(self, instance):
-        with RADOSClient(self, self.pool) as client:
-
-            def belongs_to_instance(disk):
-                return disk.startswith(instance['uuid'])
-
-            # pylint: disable=E1101
-            volumes = rbd.RBD().list(client.ioctx)
-            for volume in filter(belongs_to_instance, volumes):
-                try:
-                    rbd.RBD().remove(client.ioctx, volume)
-                except (rbd.ImageNotFound, rbd.ImageHasSnapshots):
-                    LOG.warn(_('rbd remove %(volume)s in pool %(pool)s '
-                               'failed'),
-                             {'volume': volume, 'pool': self.pool})
-
-    def get_pool_info(self):
-        with RADOSClient(self) as client:
-            stats = client.cluster.get_cluster_stats()
-            return {'total': stats['kb'] * units.Ki,
-                    'free':  stats['kb_avail'] * units.Ki,
-                    'used':  stats['kb_used'] * units.Ki}
diff --git a/nova/virt/libvirt/rbd_utils.py b/nova/virt/libvirt/rbd_utils.py
new file mode 100644
index 0000000..fce4b3d
--- /dev/null
+++ b/nova/virt/libvirt/rbd_utils.py
@@ -0,0 +1,274 @@
+# Copyright 2012 Grid Dynamics
+# Copyright 2013 Inktank Storage, Inc.
+# Copyright 2014 Mirantis, Inc.
+#
+#    Licensed under the Apache License, Version 2.0 (the "License"); you may
+#    not use this file except in compliance with the License. You may obtain
+#    a copy of the License at
+#
+#         http://www.apache.org/licenses/LICENSE-2.0
+#
+#    Unless required by applicable law or agreed to in writing, software
+#    distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+#    License for the specific language governing permissions and limitations
+#    under the License.
+
+import urllib
+
+try:
+    import rados
+    import rbd
+except ImportError:
+    rados = None
+    rbd = None
+
+from nova import exception
+from nova.openstack.common import excutils
+from nova.openstack.common.gettextutils import _
+from nova.openstack.common import jsonutils
+from nova.openstack.common import log as logging
+from nova.openstack.common import units
+from nova import utils
+
+LOG = logging.getLogger(__name__)
+
+
+class RBDVolumeProxy(object):
+    """Context manager for dealing with an existing rbd volume.
+
+    This handles connecting to rados and opening an ioctx automatically, and
+    otherwise acts like a librbd Image object.
+
+    The underlying librados client and ioctx can be accessed as the attributes
+    'client' and 'ioctx'.
+    """
+    def __init__(self, driver, name, pool=None, snapshot=None,
+                 read_only=False):
+        client, ioctx = driver._connect_to_rados(pool)
+        try:
+            snap_name = snapshot.encode('utf8') if snapshot else None
+            self.volume = rbd.Image(ioctx, name.encode('utf8'),
+                                    snapshot=snap_name,
+                                    read_only=read_only)
+        except rbd.ImageNotFound:
+            with excutils.save_and_reraise_exception():
+                LOG.debug("rbd image %s does not exist", name)
+                driver._disconnect_from_rados(client, ioctx)
+        except rbd.Error:
+            with excutils.save_and_reraise_exception():
+                LOG.exception(_("error opening rbd image %s"), name)
+                driver._disconnect_from_rados(client, ioctx)
+
+        self.driver = driver
+        self.client = client
+        self.ioctx = ioctx
+
+    def __enter__(self):
+        return self
+
+    def __exit__(self, type_, value, traceback):
+        try:
+            self.volume.close()
+        finally:
+            self.driver._disconnect_from_rados(self.client, self.ioctx)
+
+    def __getattr__(self, attrib):
+        return getattr(self.volume, attrib)
+
+
+class RADOSClient(object):
+    """Context manager to simplify error handling for connecting to ceph."""
+    def __init__(self, driver, pool=None):
+        self.driver = driver
+        self.cluster, self.ioctx = driver._connect_to_rados(pool)
+
+    def __enter__(self):
+        return self
+
+    def __exit__(self, type_, value, traceback):
+        self.driver._disconnect_from_rados(self.cluster, self.ioctx)
+
+
+class RBDDriver(object):
+
+    def __init__(self, pool, ceph_conf, rbd_user):
+        self.pool = pool.encode('utf8')
+        # NOTE(angdraug): rados.Rados fails to connect if ceph_conf is None:
+        # https://github.com/ceph/ceph/pull/1787
+        self.ceph_conf = ceph_conf.encode('utf8') if ceph_conf else ''
+        self.rbd_user = rbd_user.encode('utf8') if rbd_user else None
+        if rbd is None:
+            raise RuntimeError(_('rbd python libraries not found'))
+
+    def _connect_to_rados(self, pool=None):
+        client = rados.Rados(rados_id=self.rbd_user,
+                             conffile=self.ceph_conf)
+        try:
+            client.connect()
+            pool_to_open = pool or self.pool
+            ioctx = client.open_ioctx(pool_to_open.encode('utf-8'))
+            return client, ioctx
+        except rados.Error:
+            # shutdown cannot raise an exception
+            client.shutdown()
+            raise
+
+    def _disconnect_from_rados(self, client, ioctx):
+        # closing an ioctx cannot raise an exception
+        ioctx.close()
+        client.shutdown()
+
+    def supports_layering(self):
+        return hasattr(rbd, 'RBD_FEATURE_LAYERING')
+
+    def ceph_args(self):
+        """List of command line parameters to be passed to ceph commands to
+           reflect RBDDriver configuration such as RBD user name and location
+           of ceph.conf.
+        """
+        args = []
+        if self.rbd_user:
+            args.extend(['--id', self.rbd_user])
+        if self.ceph_conf:
+            args.extend(['--conf', self.ceph_conf])
+        return args
+
+    def get_mon_addrs(self):
+        args = ['ceph', 'mon', 'dump', '--format=json'] + self.ceph_args()
+        out, _ = utils.execute(*args)
+        lines = out.split('\n')
+        if lines[0].startswith('dumped monmap epoch'):
+            lines = lines[1:]
+        monmap = jsonutils.loads('\n'.join(lines))
+        addrs = [mon['addr'] for mon in monmap['mons']]
+        hosts = []
+        ports = []
+        for addr in addrs:
+            host_port = addr[:addr.rindex('/')]
+            host, port = host_port.rsplit(':', 1)
+            hosts.append(host.strip('[]'))
+            ports.append(port)
+        return hosts, ports
+
+    def parse_url(self, url):
+        prefix = 'rbd://'
+        if not url.startswith(prefix):
+            reason = _('Not stored in rbd')
+            raise exception.ImageUnacceptable(image_id=url, reason=reason)
+        pieces = map(urllib.unquote, url[len(prefix):].split('/'))
+        if '' in pieces:
+            reason = _('Blank components')
+            raise exception.ImageUnacceptable(image_id=url, reason=reason)
+        if len(pieces) != 4:
+            reason = _('Not an rbd snapshot')
+            raise exception.ImageUnacceptable(image_id=url, reason=reason)
+        return pieces
+
+    def _get_fsid(self):
+        with RADOSClient(self) as client:
+            return client.cluster.get_fsid()
+
+    def is_cloneable(self, image_location, image_meta):
+        url = image_location['url']
+        try:
+            fsid, pool, image, snapshot = self.parse_url(url)
+        except exception.ImageUnacceptable as e:
+            LOG.debug(_('not cloneable: %s'), e)
+            return False
+
+        if self._get_fsid() != fsid:
+            reason = _('%s is in a different ceph cluster') % url
+            LOG.debug(reason)
+            return False
+
+        if image_meta['disk_format'] != 'raw':
+            reason = _("rbd image clone requires image format to be "
+                       "'raw' but image {0} is '{1}'").format(
+                           url, image_meta['disk_format'])
+            LOG.debug(reason)
+            return False
+
+        # check that we can read the image
+        try:
+            return self.exists(image, pool=pool, snapshot=snapshot)
+        except rbd.Error as e:
+            LOG.debug(_('Unable to open image %(loc)s: %(err)s') %
+                      dict(loc=url, err=e))
+            return False
+
+    def clone(self, image_location, dest_name):
+        _fsid, pool, image, snapshot = self.parse_url(
+                image_location['url'])
+        LOG.debug(_('cloning %(pool)s/%(img)s@%(snap)s') %
+                  dict(pool=pool, img=image, snap=snapshot))
+        with RADOSClient(self, str(pool)) as src_client:
+            with RADOSClient(self) as dest_client:
+                rbd.RBD().clone(src_client.ioctx,
+                                     image.encode('utf-8'),
+                                     snapshot.encode('utf-8'),
+                                     dest_client.ioctx,
+                                     dest_name,
+                                     features=rbd.RBD_FEATURE_LAYERING)
+
+    def size(self, name):
+        with RBDVolumeProxy(self, name) as vol:
+            return vol.size()
+
+    def resize(self, name, size):
+        """Resize RBD volume.
+
+        :name: Name of RBD object
+        :size: New size in bytes
+        """
+        LOG.debug('resizing rbd image %s to %d', name, size)
+        with RBDVolumeProxy(self, name) as vol:
+            vol.resize(size)
+
+    def exists(self, name, pool=None, snapshot=None):
+        try:
+            with RBDVolumeProxy(self, name,
+                                pool=pool,
+                                snapshot=snapshot,
+                                read_only=True):
+                return True
+        except rbd.ImageNotFound:
+            return False
+
+    def import_image(self, base, name):
+        """Import RBD volume from image file.
+
+        Uses the command line import instead of librbd since rbd import
+        command detects zeroes to preserve sparseness in the image.
+
+        :base: Path to image file
+        :name: Name of RBD volume
+        """
+        args = ['--pool', self.pool, base, name]
+        if self.supports_layering():
+            args += ['--new-format']
+        args += self.ceph_args()
+        utils.execute('rbd', 'import', *args)
+
+    def cleanup_volumes(self, instance):
+        with RADOSClient(self, self.pool) as client:
+
+            def belongs_to_instance(disk):
+                return disk.startswith(instance['uuid'])
+
+            # pylint: disable=E1101
+            volumes = rbd.RBD().list(client.ioctx)
+            for volume in filter(belongs_to_instance, volumes):
+                try:
+                    rbd.RBD().remove(client.ioctx, volume)
+                except (rbd.ImageNotFound, rbd.ImageHasSnapshots):
+                    LOG.warn(_('rbd remove %(volume)s in pool %(pool)s '
+                               'failed'),
+                             {'volume': volume, 'pool': self.pool})
+
+    def get_pool_info(self):
+        with RADOSClient(self) as client:
+            stats = client.cluster.get_cluster_stats()
+            return {'total': stats['kb'] * units.Ki,
+                    'free':  stats['kb_avail'] * units.Ki,
+                    'used':  stats['kb_used'] * units.Ki}
-- 
2.1.1

