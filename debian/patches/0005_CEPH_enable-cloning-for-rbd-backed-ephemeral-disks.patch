Author: Josh Durgin <josh.durgin@inktank.com>
Date: Wed, 22 Jan 2014 15:07:17 -0800
Description: enable cloning for rbd-backed ephemeral disks
 Currently when using rbd as an image backend, nova downloads the
 glance image to local disk and then copies it again into rbd. This
 can be very slow for large images, and wastes bandwidth as well as
 disk space.
 .
 When the glance image is stored in the same ceph cluster, the data is
 being pulled out and pushed back in unnecessarily. Instead, create a
 copy-on-write clone of the image. This is fast, and does not depend
 on the size of the image. Instead of taking minutes, booting takes
 seconds, and is not limited by the disk copy.
 .
 Add some rbd utility functions from cinder to support cloning and
 let the rbd imagebackend rely on librbd instead of the rbd
 command line tool for checking image existence.
 .
 Add a direct_fetch() method to the image backend, so backends like rbd
 can make optimizations like this. Try to use direct_fetch() for the root
 disk when it comes from an image, but fall back to fetch_to_raw() if
 direct_fetch() fails.
 .
 Instead of calling disk.get_disk_size() directly from
 verify_base_size(), which assumes the disk is stored locally, add a new
 method that is overridden by the Rbd subclass to get the disk size.
Implements: blueprint rbd-clone-image-handler
Bug-Ubuntu: https://launchpad.net/bugs/1226351
Change-Id: I9b77a50206d0eda709df8356faaeeba35d232f22
Co-Authored-By: Dmitry Borodaenko <dborodaenko@mirantis.com>
Signed-off-by: Josh Durgin <josh.durgin@inktank.com>
Signed-off-by: Zhi Yan Liu <zhiyanl@cn.ibm.com>
Signed-off-by: Dmitry Borodaenko <dborodaenko@mirantis.com>

Index: nova/nova/tests/virt/libvirt/test_imagebackend.py
===================================================================
--- nova.orig/nova/tests/virt/libvirt/test_imagebackend.py	2014-06-09 22:54:58.000000000 +0800
+++ nova/nova/tests/virt/libvirt/test_imagebackend.py	2014-06-09 22:55:03.000000000 +0800
@@ -397,14 +397,14 @@
     def test_create_image_too_small(self):
         fn = self.prepare_mocks()
         self.mox.StubOutWithMock(os.path, 'exists')
-        self.mox.StubOutWithMock(imagebackend.disk, 'get_disk_size')
+        self.mox.StubOutWithMock(imagebackend.Qcow2, 'get_disk_size')
         if self.OLD_STYLE_INSTANCE_PATH:
             os.path.exists(self.OLD_STYLE_INSTANCE_PATH).AndReturn(False)
         os.path.exists(self.DISK_INFO_PATH).AndReturn(False)
         os.path.exists(self.INSTANCES_PATH).AndReturn(True)
         os.path.exists(self.TEMPLATE_PATH).AndReturn(True)
-        imagebackend.disk.get_disk_size(self.TEMPLATE_PATH
-                                       ).AndReturn(self.SIZE)
+        imagebackend.Qcow2.get_disk_size(self.TEMPLATE_PATH
+                                         ).AndReturn(self.SIZE)
         self.mox.ReplayAll()
 
         image = self.image_class(self.INSTANCE, self.NAME)
@@ -752,6 +752,7 @@
         self.mox.VerifyAll()
 
     def test_cache_base_dir_exists(self):
+        fn = self.mox.CreateMockAnything()
         image = self.image_class(self.INSTANCE, self.NAME)
 
         self.mox.StubOutWithMock(os.path, 'exists')
@@ -821,22 +822,73 @@
         fake_processutils.fake_execute_clear_log()
         fake_processutils.stub_out_processutils_execute(self.stubs)
 
-        self.mox.StubOutWithMock(imagebackend.disk, 'get_disk_size')
-        imagebackend.disk.get_disk_size(self.TEMPLATE_PATH
-                                       ).AndReturn(self.SIZE)
-        rbd_name = "%s/%s" % (self.INSTANCE['name'], self.NAME)
+        image = self.image_class(self.INSTANCE, self.NAME)
+        self.mox.StubOutWithMock(image, 'check_image_exists')
+        image.check_image_exists().AndReturn(False)
+        image.check_image_exists().AndReturn(False)
+        rbd_name = "%s_%s" % (self.INSTANCE['uuid'], self.NAME)
         cmd = ('rbd', 'import', '--pool', self.POOL, self.TEMPLATE_PATH,
                rbd_name, '--new-format', '--id', self.USER,
                '--conf', self.CONF)
+
         self.mox.ReplayAll()
 
-        image = self.image_class(self.INSTANCE, self.NAME)
         image.create_image(fn, self.TEMPLATE_PATH, None)
 
         self.assertEqual(fake_processutils.fake_execute_get_log(),
             [' '.join(cmd)])
         self.mox.VerifyAll()
 
+    def test_create_image_resize(self):
+        fn = self.mox.CreateMockAnything()
+        full_size = self.SIZE * 2
+        fn(max_size=full_size, target=self.TEMPLATE_PATH)
+
+        rbd_utils.rbd.RBD_FEATURE_LAYERING = 1
+
+        fake_processutils.fake_execute_clear_log()
+        fake_processutils.stub_out_processutils_execute(self.stubs)
+
+        image = self.image_class(self.INSTANCE, self.NAME)
+        self.mox.StubOutWithMock(image, 'check_image_exists')
+        image.check_image_exists().AndReturn(False)
+        image.check_image_exists().AndReturn(False)
+        rbd_name = "%s_%s" % (self.INSTANCE['uuid'], self.NAME)
+        cmd = ('rbd', 'import', '--pool', self.POOL, self.TEMPLATE_PATH,
+               rbd_name, '--new-format', '--id', self.USER,
+               '--conf', self.CONF)
+        self.mox.StubOutWithMock(image, 'get_disk_size')
+        image.get_disk_size(rbd_name).AndReturn(self.SIZE)
+        self.mox.StubOutWithMock(image.driver, 'resize')
+        image.driver.resize(rbd_name, full_size)
+
+        self.mox.ReplayAll()
+
+        image.create_image(fn, self.TEMPLATE_PATH, full_size)
+
+        self.assertEqual(fake_processutils.fake_execute_get_log(),
+            [' '.join(cmd)])
+        self.mox.VerifyAll()
+
+    def test_create_image_already_exists(self):
+        rbd_utils.rbd.RBD_FEATURE_LAYERING = 1
+
+        image = self.image_class(self.INSTANCE, self.NAME)
+        self.mox.StubOutWithMock(image, 'check_image_exists')
+        image.check_image_exists().AndReturn(True)
+        self.mox.StubOutWithMock(image, 'get_disk_size')
+        image.get_disk_size(self.TEMPLATE_PATH).AndReturn(self.SIZE)
+        image.check_image_exists().AndReturn(True)
+        rbd_name = "%s_%s" % (self.INSTANCE['uuid'], self.NAME)
+        image.get_disk_size(rbd_name).AndReturn(self.SIZE)
+
+        self.mox.ReplayAll()
+
+        fn = self.mox.CreateMockAnything()
+        image.create_image(fn, self.TEMPLATE_PATH, self.SIZE)
+
+        self.mox.VerifyAll()
+
     def test_prealloc_image(self):
         CONF.set_override('preallocate_images', 'space')
 
@@ -876,6 +928,67 @@
 
         self.assertEqual(image.path, rbd_path)
 
+    def test_direct_fetch_success(self):
+        location = {'url': 'rbd://a/b/c/d'}
+        meta = {'disk_format': 'raw'}
+        image = self.image_class(self.INSTANCE, self.NAME)
+
+        self.mox.StubOutWithMock(image, 'check_image_exists')
+        image.check_image_exists().AndReturn(False)
+        self.mox.StubOutWithMock(image.driver, 'supports_layering')
+        image.driver.supports_layering().AndReturn(True)
+        self.mox.StubOutWithMock(image.driver, 'is_cloneable')
+        image.driver.is_cloneable(location, meta).AndReturn(True)
+        self.mox.StubOutWithMock(image.driver, 'clone')
+        image.driver.clone(location, image.rbd_name)
+        self.mox.ReplayAll()
+
+        image.direct_fetch('image_id', meta, [location])
+
+        self.mox.VerifyAll()
+
+    def test_direct_fetch_fail_no_layering(self):
+        location = {'url': 'rbd://a/b/c/d'}
+        meta = {'disk_format': 'raw'}
+        image = self.image_class(self.INSTANCE, self.NAME)
+
+        self.mox.StubOutWithMock(image, 'check_image_exists')
+        image.check_image_exists().AndReturn(False)
+        self.mox.StubOutWithMock(image.driver, 'supports_layering')
+        image.driver.supports_layering().AndReturn(False)
+        self.mox.ReplayAll()
+
+        self.assertRaises(exception.ImageUnacceptable,
+                          image.direct_fetch, 'image_id', meta, [location])
+
+    def test_direct_fetch_fail_not_raw(self):
+        location = {'url': 'rbd://a/b/c/d'}
+        meta = {}
+        image = self.image_class(self.INSTANCE, self.NAME)
+
+        self.mox.StubOutWithMock(image, 'check_image_exists')
+        image.check_image_exists().AndReturn(False)
+        self.mox.ReplayAll()
+
+        self.assertRaises(exception.ImageUnacceptable,
+                          image.direct_fetch, 'image_id', meta, [location])
+
+    def test_direct_fetch_fail_no_locations(self):
+        location = {'url': 'rbd://a/b/c/d'}
+        meta = {'disk_format': 'raw'}
+        image = self.image_class(self.INSTANCE, self.NAME)
+
+        self.mox.StubOutWithMock(image, 'check_image_exists')
+        image.check_image_exists().AndReturn(False)
+        self.mox.StubOutWithMock(image.driver, 'supports_layering')
+        image.driver.supports_layering().AndReturn(True)
+        self.mox.StubOutWithMock(image.driver, 'is_cloneable')
+        image.driver.is_cloneable(location, meta).AndReturn(False)
+        self.mox.ReplayAll()
+
+        self.assertRaises(exception.ImageUnacceptable,
+                          image.direct_fetch, 'image_id', meta, [location])
+
 
 class BackendTestCase(test.NoDBTestCase):
     INSTANCE = {'name': 'fake-instance',
Index: nova/nova/tests/virt/libvirt/test_libvirt.py
===================================================================
--- nova.orig/nova/tests/virt/libvirt/test_libvirt.py	2014-06-09 22:54:58.000000000 +0800
+++ nova/nova/tests/virt/libvirt/test_libvirt.py	2014-06-09 22:55:03.000000000 +0800
@@ -7947,7 +7947,7 @@
         user_id = 'fake'
         project_id = 'fake'
         images.fetch_to_raw(context, image_id, target, user_id, project_id,
-                            max_size=0)
+                            max_size=0, backend=None)
 
         self.mox.ReplayAll()
         libvirt_utils.fetch_image(context, target, image_id,
Index: nova/nova/tests/virt/libvirt/test_rbd_utils.py
===================================================================
--- nova.orig/nova/tests/virt/libvirt/test_rbd_utils.py	2014-06-09 22:54:58.000000000 +0800
+++ nova/nova/tests/virt/libvirt/test_rbd_utils.py	2014-06-09 22:55:03.000000000 +0800
@@ -13,8 +13,8 @@
 
 import mock
 
+from nova import exception
 from nova.openstack.common import log as logging
-from nova.openstack.common import units
 from nova import test
 from nova import utils
 from nova.virt.libvirt import rbd_utils
@@ -77,6 +77,64 @@
     def tearDown(self):
         super(RBDTestCase, self).tearDown()
 
+    def test_good_locations(self):
+        locations = ['rbd://fsid/pool/image/snap',
+                     'rbd://%2F/%2F/%2F/%2F', ]
+        map(self.driver.parse_url, locations)
+
+    def test_bad_locations(self):
+        locations = ['rbd://image',
+                     'http://path/to/somewhere/else',
+                     'rbd://image/extra',
+                     'rbd://image/',
+                     'rbd://fsid/pool/image/',
+                     'rbd://fsid/pool/image/snap/',
+                     'rbd://///', ]
+        for loc in locations:
+            self.assertRaises(exception.ImageUnacceptable,
+                              self.driver.parse_url, loc)
+            self.assertFalse(self.driver.is_cloneable({'url': loc},
+                                                      {'disk_format': 'raw'}))
+
+    def test_cloneable(self):
+        with mock.patch.object(self.driver, '_get_fsid') as mock_get_fsid:
+            mock_get_fsid.return_value = 'abc'
+            location = {'url': 'rbd://abc/pool/image/snap'}
+            info = {'disk_format': 'raw'}
+            self.assertTrue(self.driver.is_cloneable(location, info))
+            self.assertTrue(mock_get_fsid.called)
+
+    def test_uncloneable_different_fsid(self):
+        with mock.patch.object(self.driver, '_get_fsid') as mock_get_fsid:
+            mock_get_fsid.return_value = 'abc'
+            location = {'url': 'rbd://def/pool/image/snap'}
+            self.assertFalse(
+                self.driver.is_cloneable(location, {'disk_format': 'raw'}))
+            self.assertTrue(mock_get_fsid.called)
+
+    @mock.patch.object(rbd_utils, 'RBDVolumeProxy')
+    def test_uncloneable_unreadable(self, mock_proxy):
+        with mock.patch.object(self.driver, '_get_fsid') as mock_get_fsid:
+            mock_get_fsid.return_value = 'abc'
+            location = {'url': 'rbd://abc/pool/image/snap'}
+
+            mock_proxy.side_effect = self.mock_rbd.Error
+
+            self.assertFalse(
+                self.driver.is_cloneable(location, {'disk_format': 'raw'}))
+            mock_proxy.assert_called_once()
+            self.assertTrue(mock_get_fsid.called)
+
+    def test_uncloneable_bad_format(self):
+        with mock.patch.object(self.driver, '_get_fsid') as mock_get_fsid:
+            mock_get_fsid.return_value = 'abc'
+            location = {'url': 'rbd://abc/pool/image/snap'}
+            formats = ['qcow2', 'vmdk', 'vdi']
+            for f in formats:
+                self.assertFalse(
+                    self.driver.is_cloneable(location, {'disk_format': f}))
+            self.assertTrue(mock_get_fsid.called)
+
     def test_get_mon_addrs(self):
         with mock.patch.object(utils, 'execute') as mock_execute:
             mock_execute.return_value = (CEPH_MON_DUMP, '')
@@ -84,6 +142,35 @@
             ports = ['6789', '6790', '6791', '6792', '6791']
             self.assertEqual((hosts, ports), self.driver.get_mon_addrs())
 
+    @mock.patch.object(rbd_utils, 'RADOSClient')
+    def test_clone(self, mock_client):
+        pool = u'images'
+        image = u'image-name'
+        snap = u'snapshot-name'
+        location = {'url': u'rbd://fsid/%s/%s/%s' % (pool, image, snap)}
+
+        client_stack = []
+
+        def mock__enter__(inst):
+            def _inner():
+                client_stack.append(inst)
+                return inst
+            return _inner
+
+        client = mock_client.return_value
+        # capture both rados client used to perform the clone
+        client.__enter__.side_effect = mock__enter__(client)
+
+        self.mock_rbd.RBD.clone = mock.Mock()
+
+        self.driver.clone(location, self.volume_name)
+
+        args = [client_stack[0].ioctx, str(image), str(snap),
+                client_stack[1].ioctx, str(self.volume_name)]
+        kwargs = {'features': self.mock_rbd.RBD_FEATURE_LAYERING}
+        self.mock_rbd.RBD.clone.assert_called_once_with(*args, **kwargs)
+        self.assertEqual(client.__enter__.call_count, 2)
+
     def test_resize(self):
         size = 1024
 
@@ -91,7 +178,7 @@
             proxy = proxy_init.return_value
             proxy.__enter__.return_value = proxy
             self.driver.resize(self.volume_name, size)
-            proxy.resize.assert_called_once_with(size * units.Ki)
+            proxy.resize.assert_called_once_with(size)
 
     def test_rbd_volume_proxy_init(self):
         with mock.patch.object(self.driver, '_connect_to_rados') as \
@@ -157,6 +244,17 @@
         self.assertEqual(['--id', 'foo', '--conf', '/path/bar.conf'],
                          self.driver.ceph_args())
 
+    def test_exists(self):
+        snapshot = 'snap'
+
+        with mock.patch.object(rbd_utils, 'RBDVolumeProxy') as proxy_init:
+            proxy = proxy_init.return_value
+            self.assertTrue(self.driver.exists(self.volume_name,
+                                               self.rbd_pool,
+                                               snapshot))
+            proxy.__enter__.assert_called_once()
+            proxy.__exit__.assert_called_once()
+
     def test_cleanup_volumes(self):
         instance = {'uuid': '12345'}
 
Index: nova/nova/tests/virt/test_images.py
===================================================================
--- nova.orig/nova/tests/virt/test_images.py	2014-06-09 22:54:45.000000000 +0800
+++ nova/nova/tests/virt/test_images.py	2014-06-09 22:55:03.000000000 +0800
@@ -12,6 +12,7 @@
 #    License for the specific language governing permissions and limitations
 #    under the License.
 
+import mock
 
 from nova import test
 from nova.virt import images
@@ -22,3 +23,36 @@
         image_info = images.qemu_img_info("/path/that/does/not/exist")
         self.assertTrue(image_info)
         self.assertTrue(str(image_info))
+
+
+class FetchImagesTestCase(test.NoDBTestCase):
+
+    @mock.patch('nova.image.glance.get_remote_image_service')
+    @mock.patch('nova.openstack.common.fileutils.remove_path_on_error')
+    def test_fetch(self, mock_fileutils, mock_glance):
+        mock_image_service = mock.Mock()
+        mock_glance.return_value = [mock_image_service, 'image_id']
+
+        images.fetch('context', None, 'path', None, None)
+
+        mock_image_service.download.assert_called_with(
+                'context', 'image_id', dst_path='path')
+
+    @mock.patch('nova.image.glance.get_remote_image_service')
+    def test_direct_fetch(self, mock_glance):
+        mock_image_service = mock.Mock()
+        mock_glance.return_value = [mock_image_service, 'image_id']
+        mock_image_service._get_locations.return_value = 'locations'
+        mock_image_service.show.return_value = 'image_meta'
+        mock_backend = mock.Mock()
+
+        images.direct_fetch('context', 'image_href', mock_backend)
+
+        mock_backend.direct_fetch.assert_called_with(
+                'image_id', 'image_meta', 'locations')
+
+    @mock.patch('nova.virt.images.direct_fetch')
+    def test_fetch_to_raw_direct_fetch(self, mock_direct_fetch):
+        images.fetch_to_raw('context', 'image', None, None, None,
+                            backend='backend')
+        mock_direct_fetch.assert_called_with('context', 'image', 'backend')
Index: nova/nova/virt/images.py
===================================================================
--- nova.orig/nova/virt/images.py	2014-06-09 22:54:45.000000000 +0800
+++ nova/nova/virt/images.py	2014-06-09 22:55:03.000000000 +0800
@@ -72,7 +72,33 @@
         image_service.download(context, image_id, dst_path=path)
 
 
-def fetch_to_raw(context, image_href, path, user_id, project_id, max_size=0):
+def direct_fetch(context, image_href, backend):
+    """Allow an image backend to fetch directly from the glance backend.
+
+    :backend: the image backend, which must have a direct_fetch method
+              accepting a list of image locations. This method should raise
+              exceptions.ImageUnacceptable if the image cannot be downloaded
+              directly.
+    """
+    # TODO(jdurgin): improve auth handling as noted in fetch()
+    image_service, image_id = glance.get_remote_image_service(context,
+                                                              image_href)
+    locations = image_service._get_locations(context, image_id)
+    image_meta = image_service.show(context, image_id)
+
+    LOG.debug(_('Image locations are: %(locs)s') % {'locs': locations})
+    backend.direct_fetch(image_id, image_meta, locations)
+
+
+def fetch_to_raw(context, image_href, path, user_id, project_id, max_size=0,
+                 backend=None):
+    if backend:
+        try:
+            direct_fetch(context, image_href, backend)
+            return
+        except exception.ImageUnacceptable:
+            LOG.debug(_('could not fetch directly, falling back to download'))
+
     path_tmp = "%s.part" % path
     fetch(context, image_href, path_tmp, user_id, project_id,
           max_size=max_size)
Index: nova/nova/virt/libvirt/driver.py
===================================================================
--- nova.orig/nova/virt/libvirt/driver.py	2014-06-09 22:54:58.000000000 +0800
+++ nova/nova/virt/libvirt/driver.py	2014-06-09 22:55:03.000000000 +0800
@@ -2616,13 +2616,15 @@
             if size == 0 or suffix == '.rescue':
                 size = None
 
-            image('disk').cache(fetch_func=libvirt_utils.fetch_image,
-                                context=context,
-                                filename=root_fname,
-                                size=size,
-                                image_id=disk_images['image_id'],
-                                user_id=instance['user_id'],
-                                project_id=instance['project_id'])
+            backend = image('disk')
+            backend.cache(fetch_func=libvirt_utils.fetch_image,
+                          context=context,
+                          filename=root_fname,
+                          size=size,
+                          backend=backend,
+                          image_id=disk_images['image_id'],
+                          user_id=instance['user_id'],
+                          project_id=instance['project_id'])
 
         # Lookup the filesystem type if required
         os_type_with_default = disk.get_fs_type_for_os_type(
Index: nova/nova/virt/libvirt/imagebackend.py
===================================================================
--- nova.orig/nova/virt/libvirt/imagebackend.py	2014-06-09 22:54:58.000000000 +0800
+++ nova/nova/virt/libvirt/imagebackend.py	2014-06-09 22:55:03.000000000 +0800
@@ -206,8 +206,7 @@
                                            'path': self.path})
         return can_fallocate
 
-    @staticmethod
-    def verify_base_size(base, size, base_size=0):
+    def verify_base_size(self, base, size, base_size=0):
         """Check that the base image is not larger than size.
            Since images can't be generally shrunk, enforce this
            constraint taking account of virtual image size.
@@ -226,7 +225,7 @@
             return
 
         if size and not base_size:
-            base_size = disk.get_disk_size(base)
+            base_size = self.get_disk_size(base)
 
         if size < base_size:
             msg = _('%(base)s virtual size %(base_size)s '
@@ -236,6 +235,9 @@
                               'size': size})
             raise exception.FlavorDiskTooSmall()
 
+    def get_disk_size(self, name):
+        disk.get_disk_size(name)
+
     def snapshot_extract(self, target, out_format):
         raise NotImplementedError()
 
@@ -304,6 +306,14 @@
         '''
         return False
 
+    def direct_fetch(self, image_id, image_meta, image_locations):
+        """Create an image from a direct image location.
+
+        :raises: exception.ImageUnacceptable if it cannot be fetched directly
+        """
+        reason = _('direct_fetch() is not implemented')
+        raise exception.ImageUnacceptable(image_id=image_id, reason=reason)
+
 
 class Raw(Image):
     def __init__(self, instance=None, disk_name=None, path=None):
@@ -561,30 +571,35 @@
         return False
 
     def check_image_exists(self):
-        rbd_volumes = libvirt_utils.list_rbd_volumes(self.pool)
-        for vol in rbd_volumes:
-            if vol.startswith(self.rbd_name):
-                return True
+        return self.driver.exists(self.rbd_name)
 
-        return False
+    def get_disk_size(self, name):
+        """Returns the size of the virtual disk in bytes.
+
+        The name argument is ignored since this backend already knows
+        its name, and callers may pass a non-existent local file path.
+        """
+        return self.driver.size(self.rbd_name)
 
     def create_image(self, prepare_template, base, size, *args, **kwargs):
-        if not os.path.exists(base):
+
+        if not self.check_image_exists():
             prepare_template(target=base, max_size=size, *args, **kwargs)
         else:
             self.verify_base_size(base, size)
 
-        # keep using the command line import instead of librbd since it
-        # detects zeroes to preserve sparseness in the image
-        args = ['--pool', self.pool, base, self.rbd_name]
-        if self.driver.supports_layering():
-            args += ['--new-format']
-        args += self.driver.ceph_args()
-        utils.execute('rbd', 'import', *args)
-
-        base_size = disk.get_disk_size(base)
+        # prepare_template() may have cloned the image into a new rbd
+        # image already instead of downloading it locally
+        if not self.check_image_exists():
+            # keep using the command line import instead of librbd since it
+            # detects zeroes to preserve sparseness in the image
+            args = ['--pool', self.pool, base, self.rbd_name]
+            if self.driver.supports_layering():
+                args += ['--new-format']
+                args += self.driver.ceph_args()
+                utils.execute('rbd', 'import', *args)
 
-        if size and size > base_size:
+        if size and size > self.get_disk_size(self.rbd_name):
             self.driver.resize(self.rbd_name, size)
 
     def snapshot_extract(self, target, out_format):
@@ -594,6 +609,23 @@
     def is_shared_block_storage():
         return True
 
+    def direct_fetch(self, image_id, image_meta, image_locations):
+        if self.check_image_exists():
+            return
+        if image_meta.get('disk_format') != 'raw':
+            reason = _('Image is not raw format')
+            raise exception.ImageUnacceptable(image_id=image_id, reason=reason)
+        if not self.driver.supports_layering():
+            reason = _('installed version of librbd does not support cloning')
+            raise exception.ImageUnacceptable(image_id=image_id, reason=reason)
+
+        for location in image_locations:
+            if self.driver.is_cloneable(location, image_meta):
+                return self.driver.clone(location, self.rbd_name)
+
+        reason = _('No image locations are accessible')
+        raise exception.ImageUnacceptable(image_id=image_id, reason=reason)
+
 
 class Backend(object):
     def __init__(self, use_cow):
Index: nova/nova/virt/libvirt/rbd_utils.py
===================================================================
--- nova.orig/nova/virt/libvirt/rbd_utils.py	2014-06-09 22:54:58.000000000 +0800
+++ nova/nova/virt/libvirt/rbd_utils.py	2014-06-09 22:55:03.000000000 +0800
@@ -11,6 +11,8 @@
 #    License for the specific language governing permissions and limitations
 #    under the License.
 
+import urllib
+
 try:
     import rados
     import rbd
@@ -18,10 +20,11 @@
     rados = None
     rbd = None
 
+from nova import exception
+from nova.openstack.common import excutils
 from nova.openstack.common.gettextutils import _
 from nova.openstack.common import jsonutils
 from nova.openstack.common import log as logging
-from nova.openstack.common import units
 from nova import utils
 
 LOG = logging.getLogger(__name__)
@@ -36,14 +39,23 @@
     The underlying librados client and ioctx can be accessed as the attributes
     'client' and 'ioctx'.
     """
-    def __init__(self, driver, name, pool=None):
+    def __init__(self, driver, name, pool=None, snapshot=None,
+                 read_only=False):
         client, ioctx = driver._connect_to_rados(pool)
         try:
-            self.volume = driver.rbd.Image(ioctx, str(name), snapshot=None)
+            snap_name = snapshot.encode('utf8') if snapshot else None
+            self.volume = driver.rbd.Image(ioctx, name.encode('utf8'),
+                                           snapshot=snap_name,
+                                           read_only=read_only)
+        except driver.rbd.ImageNotFound:
+            with excutils.save_and_reraise_exception():
+                LOG.debug("rbd image %s does not exist", name)
+                driver._disconnect_from_rados(client, ioctx)
         except driver.rbd.Error:
-            LOG.exception(_("error opening rbd image %s"), name)
-            driver._disconnect_from_rados(client, ioctx)
-            raise
+            with excutils.save_and_reraise_exception():
+                LOG.exception(_("error opening rbd image %s"), name)
+                driver._disconnect_from_rados(client, ioctx)
+
         self.driver = driver
         self.client = client
         self.ioctx = ioctx
@@ -61,15 +73,17 @@
         return getattr(self.volume, attrib)
 
 
-def ascii_str(s):
-    """Convert a string to ascii, or return None if the input is None.
+class RADOSClient(object):
+    """Context manager to simplify error handling for connecting to ceph."""
+    def __init__(self, driver, pool=None):
+        self.driver = driver
+        self.cluster, self.ioctx = driver._connect_to_rados(pool)
+
+    def __enter__(self):
+        return self
 
-    This is useful when a parameter is None by default, or a string. LibRBD
-    only accepts ascii, hence the need for conversion.
-    """
-    if s is None:
-        return s
-    return str(s)
+    def __exit__(self, type_, value, traceback):
+        self.driver._disconnect_from_rados(self.cluster, self.ioctx)
 
 
 class RBDDriver(object):
@@ -91,8 +105,8 @@
                                   conffile=self.ceph_conf)
         try:
             client.connect()
-            pool_to_open = str(pool or self.pool)
-            ioctx = client.open_ioctx(pool_to_open)
+            pool_to_open = pool or self.pool
+            ioctx = client.open_ioctx(pool_to_open.encode('utf-8'))
             return client, ioctx
         except self.rados.Error:
             # shutdown cannot raise an exception
@@ -132,15 +146,84 @@
             ports.append(port)
         return hosts, ports
 
+    def parse_url(self, url):
+        prefix = 'rbd://'
+        if not url.startswith(prefix):
+            reason = _('Not stored in rbd')
+            raise exception.ImageUnacceptable(image_id=url, reason=reason)
+        pieces = map(urllib.unquote, url[len(prefix):].split('/'))
+        if '' in pieces:
+            reason = _('Blank components')
+            raise exception.ImageUnacceptable(image_id=url, reason=reason)
+        if len(pieces) != 4:
+            reason = _('Not an rbd snapshot')
+            raise exception.ImageUnacceptable(image_id=url, reason=reason)
+        return pieces
+
+    def _get_fsid(self):
+        with RADOSClient(self) as client:
+            return client.cluster.get_fsid()
+
+    def is_cloneable(self, image_location, image_meta):
+        url = image_location['url']
+        try:
+            fsid, pool, image, snapshot = self.parse_url(url)
+        except exception.ImageUnacceptable as e:
+            LOG.debug(_('not cloneable: %s'), e)
+            return False
+
+        if self._get_fsid() != fsid:
+            reason = _('%s is in a different ceph cluster') % url
+            LOG.debug(reason)
+            return False
+
+        if image_meta['disk_format'] != 'raw':
+            reason = _("rbd image clone requires image format to be "
+                       "'raw' but image {0} is '{1}'").format(
+                           url, image_meta['disk_format'])
+            LOG.debug(reason)
+            return False
+
+        # check that we can read the image
+        try:
+            return self.exists(image, pool=pool, snapshot=snapshot)
+        except self.rbd.Error as e:
+            LOG.debug(_('Unable to open image %(loc)s: %(err)s') %
+                      dict(loc=url, err=e))
+            return False
+
+    def clone(self, image_location, dest_name):
+        _fsid, pool, image, snapshot = self.parse_url(
+                image_location['url'])
+        LOG.debug(_('cloning %(pool)s/%(img)s@%(snap)s') %
+                  dict(pool=pool, img=image, snap=snapshot))
+        with RADOSClient(self, str(pool)) as src_client:
+            with RADOSClient(self) as dest_client:
+                self.rbd.RBD().clone(src_client.ioctx,
+                                     image.encode('utf-8'),
+                                     snapshot.encode('utf-8'),
+                                     dest_client.ioctx,
+                                     dest_name,
+                                     features=self.rbd.RBD_FEATURE_LAYERING)
+
     def size(self, name):
         with RBDVolumeProxy(self, name) as vol:
             return vol.size()
 
-    def resize(self, volume_name, size):
-        size = int(size) * units.Ki
+    def resize(self, name, size_bytes):
+        LOG.debug('resizing rbd image %s to %d', name, size_bytes)
+        with RBDVolumeProxy(self, name) as vol:
+            vol.resize(size_bytes)
 
-        with RBDVolumeProxy(self, volume_name) as vol:
-            vol.resize(size)
+    def exists(self, name, pool=None, snapshot=None):
+        try:
+            with RBDVolumeProxy(self, name,
+                                pool=pool,
+                                snapshot=snapshot,
+                                read_only=True):
+                return True
+        except self.rbd.ImageNotFound:
+            return False
 
     def cleanup_volumes(self, instance):
         with RADOSClient(self, self.pool) as client:
Index: nova/nova/virt/libvirt/utils.py
===================================================================
--- nova.orig/nova/virt/libvirt/utils.py	2014-06-09 22:54:58.000000000 +0800
+++ nova/nova/virt/libvirt/utils.py	2014-06-09 22:55:03.000000000 +0800
@@ -607,10 +607,11 @@
             'used': used}
 
 
-def fetch_image(context, target, image_id, user_id, project_id, max_size=0):
+def fetch_image(context, target, image_id, user_id, project_id, max_size=0,
+                backend=None):
     """Grab image."""
     images.fetch_to_raw(context, image_id, target, user_id, project_id,
-                        max_size=max_size)
+                        max_size=max_size, backend=backend)
 
 
 def get_instance_path(instance, forceold=False, relative=False):
