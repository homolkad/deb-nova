--- a/.gitreview
+++ b/.gitreview
@@ -2,3 +2,4 @@
 host=review.openstack.org
 port=29418
 project=openstack/nova.git
+defaultbranch=stable/essex
--- a/nova/network/quantum/nova_ipam_lib.py
+++ b/nova/network/quantum/nova_ipam_lib.py
@@ -47,10 +47,6 @@
         """
         self.net_manager = net_manager
 
-        # NOTE(s0mik) : If DHCP is not in use, we need to timeout IPs
-        # periodically.  See comment in deallocate_ips_by_vif for more
-        self.net_manager.timeout_fixed_ips = not self.net_manager.DHCP
-
     def create_subnet(self, context, label, tenant_id,
                       quantum_net_id, priority, cidr=None,
                       gateway=None, gateway_v6=None, cidr_v6=None,
@@ -224,16 +220,12 @@
         # be disassociated with the instance-id by a call to one of two
         # methods inherited from FlatManager:
         # - if DHCP is in use, a lease expiring in dnsmasq triggers
-        #   a call to release_fixed_ip in the network manager.
-        # - otherwise, _disassociate_stale_fixed_ips is called periodically
-        #   to disassociate all fixed ips that are unallocated
-        #   but still associated with an instance-id.
+        #   a call to release_fixed_ip in the network manager, or it will
+        #   be timed out periodically if the lease fails.
+        # - otherwise, we release the ip immediately
 
         read_deleted_context = admin_context.elevated(read_deleted='yes')
         for fixed_ip in fixed_ips:
-            db.fixed_ip_update(admin_context, fixed_ip['address'],
-                               {'allocated': False,
-                                'virtual_interface_id': None})
             fixed_id = fixed_ip['id']
             floating_ips = self.net_manager.db.floating_ip_get_by_fixed_ip_id(
                                 admin_context,
@@ -252,6 +244,11 @@
                         read_deleted_context,
                         address,
                         affect_auto_assigned=True)
+            db.fixed_ip_update(admin_context, fixed_ip['address'],
+                               {'allocated': False,
+                                'virtual_interface_id': None})
+            if not self.net_manager.DHCP:
+                db.fixed_ip_disassociate(admin_context, fixed_ip['address'])
 
         if len(fixed_ips) == 0:
             LOG.error(_('No fixed IPs to deallocate for vif %s') %
--- a/nova/tests/fake_libvirt_utils.py
+++ b/nova/tests/fake_libvirt_utils.py
@@ -14,6 +14,7 @@
 #    License for the specific language governing permissions and limitations
 #    under the License.
 
+import os
 import StringIO
 
 files = {}
@@ -89,7 +90,11 @@
 
 
 def load_file(path):
-    return ''
+    if os.path.exists(path):
+        with open(path, 'r+') as fp:
+            return fp.read()
+    else:
+        return ''
 
 
 def file_delete(path):
--- a/nova/tests/test_libvirt.py
+++ b/nova/tests/test_libvirt.py
@@ -1194,7 +1194,8 @@
         self.mox.StubOutWithMock(conn, "volume_driver_method")
         for v in vol['block_device_mapping']:
             conn.volume_driver_method('connect_volume',
-                                     v['connection_info'], v['mount_device'])
+                                     v['connection_info'],
+                                     v['mount_device'].rpartition("/")[2])
 
         # Starting test
         self.mox.ReplayAll()
@@ -1329,7 +1330,6 @@
             shutil.rmtree(os.path.join(FLAGS.instances_path,
                                        FLAGS.base_dir_name))
 
-    @test.skip_if(missing_libvirt(), "Test requires libvirt")
     def test_get_console_output_file(self):
 
         with utils.tempdir() as tmpdir:
@@ -1364,13 +1364,12 @@
 
             self.create_fake_libvirt_mock()
             connection.LibvirtConnection._conn.lookupByName = fake_lookup
-            connection.libvirt_utils = libvirt_utils
+            connection.libvirt_utils = fake_libvirt_utils
 
             conn = connection.LibvirtConnection(False)
             output = conn.get_console_output(instance)
             self.assertEquals("foo", output)
 
-    @test.skip_if(missing_libvirt(), "Test requires libvirt")
     def test_get_console_output_pty(self):
 
         with utils.tempdir() as tmpdir:
@@ -1403,9 +1402,14 @@
             def fake_lookup(id):
                 return FakeVirtDomain(fake_dom_xml)
 
+            def _fake_flush(self, fake_pty):
+                with open(fake_pty, 'r+') as fp:
+                    return fp.read()
+
             self.create_fake_libvirt_mock()
             connection.LibvirtConnection._conn.lookupByName = fake_lookup
-            connection.libvirt_utils = libvirt_utils
+            connection.LibvirtConnection._flush_libvirt_console = _fake_flush
+            connection.libvirt_utils = fake_libvirt_utils
 
             conn = connection.LibvirtConnection(False)
             output = conn.get_console_output(instance)
--- a/nova/version.py
+++ b/nova/version.py
@@ -14,9 +14,9 @@
 #    License for the specific language governing permissions and limitations
 #    under the License.
 
-NOVA_VERSION = ['2012', '1', '1']
+NOVA_VERSION = ['2012', '1', '2']
 YEAR, COUNT, REVISION = NOVA_VERSION
-FINAL = True   # This becomes true at Release Candidate time
+FINAL = False   # This becomes true at Release Candidate time
 
 
 def canonical_version_string():
--- a/nova/virt/libvirt/connection.py
+++ b/nova/virt/libvirt/connection.py
@@ -473,10 +473,10 @@
             block_device_info)
         for vol in block_device_mapping:
             connection_info = vol['connection_info']
-            mountpoint = vol['mount_device']
+            mount_device = vol['mount_device'].rpartition("/")[2]
             self.volume_driver_method('disconnect_volume',
                                       connection_info,
-                                      mountpoint)
+                                      mount_device)
         if cleanup:
             self._cleanup(instance)
 
@@ -2126,10 +2126,10 @@
             block_device_info)
         for vol in block_device_mapping:
             connection_info = vol['connection_info']
-            mountpoint = vol['mount_device']
+            mount_device = vol['mount_device'].rpartition("/")[2]
             self.volume_driver_method('connect_volume',
                                       connection_info,
-                                      mountpoint)
+                                      mount_device)
 
     def pre_block_migration(self, ctxt, instance_ref, disk_info_json):
         """Preparation block migration.
